<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta property="og:type" content="website">
<meta property="og:title" content="AnanZhang">
<meta property="og:url" content="http://vernlium.github.io/index.html">
<meta property="og:site_name" content="AnanZhang">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="AnanZhang">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://vernlium.github.io/"/>





  <title>AnanZhang</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">AnanZhang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Keep codeing and thinking!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://vernlium.github.io/2017/04/19/today-is-tomorrow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Anan Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnanZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/19/today-is-tomorrow/" itemprop="url">today is tomorrow</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-19T21:21:57+08:00">
                2017-04-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天晚上看了一部电影《土拔鼠之日》，感触颇多。</p>
<p>认真的过好每一天，你想要的美好的明天就会到来。</p>
<p>当你自暴自弃的放弃一天时，你会发现今天就是昨天的重复，每一天都像是昨天，每天醒来都会让你觉得仿佛在昨天。你想要的明天永远不会到来。</p>
<p>当你充实的过每一天，仿佛每一天都是新的，每一天都不同，每一天的自己都是快乐的。不知不觉中，明天悄然来临。</p>
<p>不要让自己重复在昨天，每一天都不一样，每一天都值得你去学习，去进步，去成长，去发现生活的美，去帮助别人，去让自己快乐。美好的结局不是处心积虑的谋划，是点点滴滴的积累。开心快乐积极的拥抱每一天，美好的明天总会到来。</p>
<p>享受每一个今天，不管明天会不会来。</p>
<p>前几天，荣生哥哥微信分享的一句话很好：<strong>现状系前因，现因承后果。</strong>不要在叹息昨天的失去中让今天变成了昨天，每一天都是新的，抓住今天，明天会有所不同。</p>
<p>这部电影的一些台词也很好，记录几个：</p>
<blockquote>
<p>No mater what happen tomorrow or the rest of my life,I am happy now because I love you.</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://vernlium.github.io/2015/12/27/Java正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Anan Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnanZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/27/Java正则表达式/" itemprop="url">Java正则表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-27T22:43:35+08:00">
                2015-12-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://vernlium.github.io/2015/10/29/Maven简明教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Anan Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnanZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/29/Maven简明教程/" itemprop="url">Maven简明教程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-29T22:09:54+08:00">
                2015-10-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Maven/" itemprop="url" rel="index">
                    <span itemprop="name">Maven</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          这是一个Maven简明教程，包括Maven入门和深入了解
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2015/10/29/Maven简明教程/">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://vernlium.github.io/2015/10/11/《深入理解Java虚拟机》读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Anan Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnanZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/10/11/《深入理解Java虚拟机》读书笔记/" itemprop="url">《深入理解Java虚拟机》读书笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-10-11T20:41:32+08:00">
                2015-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>这一块书上讲的内容很繁杂，而且很多，看到晕头转向的，结合<a href="http://blog.csdn.net/luanlouis/article/details/40043991" target="_blank" rel="external">这篇博客</a>的内容，总结了下图，我觉得还是比较清晰的。</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vernJVM运行时数据区.jpg"></p>
<h3 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h3><h4 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1.对象的创建"></a>1.对象的创建</h4><p>new关键字创建一个对象时，虚拟机中对象的创建过程：</p>
<p>（1）虚拟机检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经加载、解析和初始化过。如果没有，则必须先执行相应的类加载过程。</p>
<p>（2）虚拟机为新生对象分配内存，对象所需内存的大小在类加载完成后已经确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p>
<p>内存分配方式有两种：指针碰撞和空闲列表。内存分配方式由Java堆是否规整有关，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p>还有一个要考虑的问题是，多个线程同时新对象，如何解决并发问题。解决这个问题有两种方案：意识对分配内存空间的动作进行同步处理；另一种是把内存分配的动作按照线程划分在不同的空间之中急性，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。</p>
<p>（3）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。</p>
<p>（4）接下来，虚拟机对对象惊喜必要的设置，如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄等信息。</p>
<p>（5）上面的工作都完成之后，从虚拟机的视角看，一个新的对象已经产生了，但是从Java程序的视角来看，对象的创建才刚刚开始——<init>方法还没执行，所有的字段都还是零。所以，一般来说，执行new指令后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成产生出来。</init></init></p>
<h4 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2.对象的内存布局"></a>2.对象的内存布局</h4><p>对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<p>对象头包括两部分信息：第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为“Mark Word”。</p>
<p>对象头的另一部分是类型支持，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>数据实例部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</p>
<p>第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。</p>
<h4 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3.对象的访问定位"></a>3.对象的访问定位</h4><p>Java程序通过栈上的reference数据来操作对上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。</p>
<ul>
<li>如果直接使用句柄访问，java堆中将会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址，而句柄中包含了对象数据与类型数据各自的具体地址信息，如下图所示。</li>
</ul>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vern通过句柄访问对象.jpg" alt="通过句柄访问对象"></p>
<ul>
<li>如果使用直接指针访问，那么java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址，如下图所示。</li>
</ul>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vern通过直接指针访问对象.jpg" alt="通过直接指针访问对象"></p>
<p>这两种对象访问方式各有优势，使用句柄来访问的最大好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p>
<p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销。HotSpot虚拟机使用的是直接指针访问的方式。句柄来访问的情况也十分常见。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>垃圾收集（Garbage Collection,GC）需要完成3件事：</p>
<ul>
<li><strong>哪些内存需要回收？</strong></li>
<li><strong>什么时候回收？</strong></li>
<li><strong>如何回收？</strong></li>
</ul>
<p>Java内存的程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈和出栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束，内存自然就跟随着回收了。</p>
<p>而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收是动态的，垃圾收集器所关注的是这部分的内存。</p>
<h3 id="第一个问题：哪些内存需要回收"><a href="#第一个问题：哪些内存需要回收" class="headerlink" title="第一个问题：哪些内存需要回收"></a>第一个问题：哪些内存需要回收</h3><p>就是判断哪些对象实例还“活着”，哪些已经“死去”。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>Java中使用可达性分析（Reachability Analysis）来判定对象是否存活的。</p>
<p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）,当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vern可达性分析.jpg" alt="可达性分析"></p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
</ul>
<p>Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p>
<ul>
<li><p>强引用就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>
</li>
<li><p>软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。</p>
</li>
<li><p>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</p>
</li>
<li><p>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</p>
</li>
</ul>
<h3 id="第二个问题：什么时候回收？"><a href="#第二个问题：什么时候回收？" class="headerlink" title="第二个问题：什么时候回收？"></a>第二个问题：什么时候回收？</h3><h4 id="次收集（Minor-GC）和全收集（Full-GC）"><a href="#次收集（Minor-GC）和全收集（Full-GC）" class="headerlink" title="次收集（Minor GC）和全收集（Full GC）"></a>次收集（Minor GC）和全收集（Full GC）</h4><p>当这三个分代的堆空间比较紧张或者没有足够的空间来为新到的请求分配的时候，垃圾回收机制就会起作用。有两种类型的垃圾回收方式：次收集和全收集。当新生代堆空间满了的时候，会触发次收集将还存活的对象移到年老代堆空间。当年老代堆空间满了的时候，会触发一个覆盖全范围的对象堆的全收集。</p>
<h4 id="次收集"><a href="#次收集" class="headerlink" title="次收集"></a>次收集</h4><ul>
<li>当新生代堆空间紧张时会被触发</li>
<li>相对于全收集而言，收集间隔较短</li>
</ul>
<h4 id="全收集"><a href="#全收集" class="headerlink" title="全收集"></a>全收集</h4><ul>
<li>当老年代或者持久代堆空间满了，会触发全收集操作</li>
<li>可以使用System.gc()方法来显式的启动全收集</li>
<li>全收集一般根据堆大小的不同，需要的时间不尽相同，但一般会比较长。不过，如果全收集时间超过3到5秒钟，那就太长了</li>
</ul>
<h3 id="第三个问题：如何回收？"><a href="#第三个问题：如何回收？" class="headerlink" title="第三个问题：如何回收？"></a>第三个问题：如何回收？</h3><p>垃圾回收使用到一些垃圾收集算法。</p>
<h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><h5 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1.标记-清除算法"></a>1.标记-清除算法</h5><p>算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程就是使用可达性算法进行标记的。</p>
<p>主要缺点有两个：</p>
<ul>
<li>效率问题，标记和清除两个过程的效率都不高</li>
<li>空间问题，标记清除之后会产生大量不连续的内存碎片</li>
</ul>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vern标记清除算法.jpg" alt="标记清除算法"></p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vernmark-clean.jpg" alt="标记清理算法"></p>
<h5 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h5><p>复制算法：将可用内存按照容量分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，然后把已使用过的内存空间一次清理掉。</p>
<p>内存分配时不用考虑内存碎片问题，只要一动堆顶指针，按顺序分配内存即可，实现简单，运行高效。代价是将内存缩小为原来的一半。</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vern复制算法.jpg" alt="复制算法"></p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/verncopy.jpg" alt="复制算法"></p>
<p>实际应用中将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</p>
<p>Hotspot虚拟机中默认的Eden和Survivor的大小比例是8:1.</p>
<h5 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3.标记-整理算法"></a>3.标记-整理算法</h5><p>标记整理算法（Mark-Compact），标记过程仍然和“标记-清除”一样，但后续不走不是直接对可回收对象进行清理，而是让所有存活对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vern标记整理算法.jpg" alt="标记整理算法"></p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vernmark-trim.jpg" alt="标记整理算法"></p>
<h5 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h5><p>根据对象存活周期的不同将内存分为几块。一般把Java堆分为新生代和老年代，根据各个年代的特点采用最合适的收集算法。在新生代中，每次垃圾收集时有大批对象死去，只有少量存活，可以选用复制算法。而老年代对象存活率高，使用标记清理或者标记整理算法。</p>
<h3 id="HotSpot虚拟机内存"><a href="#HotSpot虚拟机内存" class="headerlink" title="HotSpot虚拟机内存"></a>HotSpot虚拟机内存</h3><p>下图是Sun HotSpot虚拟机的Heap区的分区，分为三个区：分别是Young Gereration新生代、Old Gerenation老年代、Permanent Generation持久区。</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vernjvm-memory-generation.png" alt="jvm-memory-generation"></p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vernYoung_generation_memory_areas.png" alt="新生代内存区域"></p>
<h3 id="Collector的职责"><a href="#Collector的职责" class="headerlink" title="Collector的职责"></a>Collector的职责</h3><ul>
<li>分配内存。</li>
<li>保证有引用的内存不被释放。</li>
<li>回收没有指针引用的内存。</li>
</ul>
<p>对象被引用称为活对象，对象没有被引用称为垃圾对象/垃圾/垃圾内存，找到垃圾对象并回收是Collector的一个主要工作，该过程称为GC。</p>
<h3 id="好的Collector的特性"><a href="#好的Collector的特性" class="headerlink" title="好的Collector的特性"></a>好的Collector的特性</h3><ul>
<li>保证有引用的对象不被GC。</li>
<li>快速的回收内存垃圾。</li>
<li>在程序运行期间GC要高效，尽量少的影响程序运行。和大部分的计算机问题一样，这是一个关于空间，时间，效率平衡的问题。</li>
<li>避免内存碎片，内存碎片导致占用大量内存的大对象内存申请难以满足。</li>
<li>良好的扩展性，内存分配和GC在多核机器上不应该成为性能瓶颈。</li>
</ul>
<h3 id="GC性能指标"><a href="#GC性能指标" class="headerlink" title="GC性能指标"></a>GC性能指标</h3><ul>
<li>Throughput: 程序时间(不包含GC时间)/总时间。</li>
<li>GC overhead: GC时间/总时间。</li>
<li>Pause time: GC运行时程序挂起时间。</li>
<li>Frequency of GC: GC频率。</li>
<li>Footprint: Size度量，如堆大小。</li>
<li>Promptness:对象变为垃圾到该垃圾被回收后内存可用的时间。</li>
</ul>
<h3 id="HotSpot虚拟机垃圾收集器"><a href="#HotSpot虚拟机垃圾收集器" class="headerlink" title="HotSpot虚拟机垃圾收集器"></a>HotSpot虚拟机垃圾收集器</h3><p>下面是Sun HotSpot虚拟机1.6版本Update22包含的所有收集器。</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vernhotspot_jvm_collector.jpg" alt="HotSpot虚拟机的垃圾收集器"></p>
<h4 id="Serial-Collecor"><a href="#Serial-Collecor" class="headerlink" title="Serial Collecor"></a>Serial Collecor</h4><p>Serial收集器是单线程收集器，是分代收集器。</p>
<p>新生代：单线程复制收集算法</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vernserial_young_generation_collection_2.png" alt="Serial收集器新生代收集过程"></p>
<p>老年代：单线程标记整理算法</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vernCompaction_of_the_old_generation.png" alt="Serial收集器老年代收集"></p>
<p>Serial一般在单核的机器上使用，是Java 5非服务端JVM的默认收集器，参数<strong>-XX:UseSerialGC</strong>设置使用。</p>
<h4 id="Parallel-Collector"><a href="#Parallel-Collector" class="headerlink" title="Parallel Collector"></a>Parallel Collector</h4><p>现在大部分的应用都是运行在多核的机器上，显然Serial收集器无法充分利用物理机的CPU资源，因此出现了Parallel收集器。Parallel收集器和Serial收集器的主要区别是新生代的收集，一个是单线程一个是多线程。可以从下图看到区别。</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vernComparison_between_serial_and_parallel_young_generation_collection.png" alt="Serial和Parallel收集器新生代收集过程对比"></p>
<p>老年代的收集和Serial收集器是一样的。</p>
<p>Parallel收集器多在CPU的服务器上，是Java5 服务器端JVM的默认收集器。参数<strong>-XX:+UseParallelGC</strong>进行设置使用。</p>
<h4 id="Parallel-Compacting-Collector"><a href="#Parallel-Compacting-Collector" class="headerlink" title="Parallel Compacting Collector"></a>Parallel Compacting Collector</h4><p>Parallel Compaction收集器出现在J2SE 5.0 update 6。和Parallel收集的主要区别在于老年代的收集，主要是为了解决老年代收集程序暂停时间过长的问题。</p>
<p>Parallel Compacting收集器分为三个阶段（每个区域在逻辑上是固定的）：</p>
<p><strong>①标记阶段（marking phase）</strong>:并行标记所有代码能够直达的存活的对象。</p>
<p><strong>②总结阶段（summary phase）</strong>:这一阶段是在区域进行而不是在对象上。一般情况下，区域靠左侧，存活对象的密度会高一些，在这一侧进行垃圾回收的花费会很高，代价大，并不值得。因此，总结阶段首先检查区域的对象密度，然后从左到右找到一个点：这个点的右侧区域垃圾收集的代价不大。这一点右侧使用标记整理算法进行回收。在收集过程中会计算并存储每一个收集区域的存活对象的新位置。这一阶段是单线程的。</p>
<p><strong>③整理阶段（compacting phase）</strong>:使用上一阶段中的数据，使用copying算法进行整理，最终一侧是高密度的存活对象，另一侧为空。</p>
<p>此收集器多使用在多CPU的服务器上，并且程序对暂停时间要求较高。参数<strong>-XX:+UseParallelOldGC</strong>来使用它。还可以通过参数-XX:ParallelGCThreads=n来指定用于GC的线程数。</p>
<h4 id="Concurrent-Mark-Sweep-CMS-Collector"><a href="#Concurrent-Mark-Sweep-CMS-Collector" class="headerlink" title="Concurrent Mark-Sweep(CMS) Collector"></a>Concurrent Mark-Sweep(CMS) Collector</h4><p>也称“low-latency collector”，为了解决老年代暂停时间过长的问题，并且真正实现并行收集（程序和GC并行执行）。</p>
<p>新生代：收集和Parallel Collector新生代收集方式一致。</p>
<p>老年代：GC和程序同时进行。</p>
<p>分为四个阶段：</p>
<p><strong>①初始标记(initial mark)</strong>:暂停一会，找出所有活着对象的初始集合。</p>
<p><strong>②并行标记(concurrent marking)</strong>：根据初始集合，标记出所有的存活对象，由于程序在运行，一部分存活对象无法标出。<br>此过程标记操作和程序同时执行。</p>
<p><strong>③重新标记(remark)</strong>:程序暂停一会，多线程进行重新标记所有在②中没有被标记的存活对象。</p>
<p><strong>④并行清理concurrent sweep</strong>：回收所有被标记的垃圾区域。和程序同时进行。</p>
<p>过程如下图所示。</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vernComparison_between_serial_and_CMS_old_generation_collection.png" alt="Serial和CMS收集器新生代收集过程对比"></p>
<p>由于此收集器在remark阶段重新访问对象，因此开销有所增加。</p>
<p>此收集器的不足是，老年代收集采用标记清除算法，因此会产生很多不连续的内存碎片。</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vernCMS_sweeping_of_old_generation.png" alt="CMS收集器老年代收集过程"></p>
<p>此收集器一般多用于对程序暂停时间要求更短的程序上，多由于web应用（实时性要求高）。参数-XX:+UseConcMarkSweepGC设置使用它。</p>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p>下面将一步步的介绍G1收集器的收集过程。</p>
<h5 id="1、G1收集器的堆结构（G1-Heap-Structure）"><a href="#1、G1收集器的堆结构（G1-Heap-Structure）" class="headerlink" title="1、G1收集器的堆结构（G1 Heap Structure）"></a>1、G1收集器的堆结构（G1 Heap Structure）</h5><p>heap区被划分成很多固定大小的区域。区域的大小由JVM启动时选择。一般情况下，JVM会产生2000个左右的区域，每个区域的大小在1到32MB不等。</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/verng1_heap_structure.png" alt="G1 Heap Structure"></p>
<h5 id="2、G1收集器的堆分配（G1-Heap-Allocation）"><a href="#2、G1收集器的堆分配（G1-Heap-Allocation）" class="headerlink" title="2、G1收集器的堆分配（G1 Heap Allocation）"></a>2、G1收集器的堆分配（G1 Heap Allocation）</h5><p>这些区域在逻辑上被影射成Eden、Survivor和老年代区。</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/verng1_heap_allocation.png" alt="G1 Heap Allocation"></p>
<p>活着的对象可以从一个区域拷贝或者移动到另一个区域。这样设计区分的划分可以在不停在其他线程的情况下分配内存空间。</p>
<h5 id="3、G1收集器的新生代（Young-Generation-in-G1）"><a href="#3、G1收集器的新生代（Young-Generation-in-G1）" class="headerlink" title="3、G1收集器的新生代（Young Generation in G1）"></a>3、G1收集器的新生代（Young Generation in G1）</h5><p>heap区被划分成大概2000个区域，最小的是1Mb，最大的是32Mb。</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vernyoung_generartion_in_g1.png" alt="Young Genertation in G1"></p>
<h5 id="4、G1收集器的新生代GC-A-Young-GC-in-G1）"><a href="#4、G1收集器的新生代GC-A-Young-GC-in-G1）" class="headerlink" title="4、G1收集器的新生代GC(A Young GC in G1）"></a>4、G1收集器的新生代GC(A Young GC in G1）</h5><p>新生代的GC，活着的对象被复制或移动到survivor区，如果对象的年龄达到设置的阈值（比如设置的阈值是10，如果对象经过10GC后仍然存活，那么这个对象就达到了阈值）这些对象将被提升到老年代区中。</p>
<p>这个阶段stop the world（所有应用的线程都停止）。然后会计算eden区和survivor区的大小，下一次新生代GC的时候会用到这些信息。</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/verng1_young_gc.png" alt="A Young GC in G1"></p>
<h5 id="5、新生代收集结束（End-of-Yonug-GC-with-G1）"><a href="#5、新生代收集结束（End-of-Yonug-GC-with-G1）" class="headerlink" title="5、新生代收集结束（End of Yonug GC with G1）"></a>5、新生代收集结束（End of Yonug GC with G1）</h5><p>存活的对象都被移到了survivor区或老年代区。这样新生代的收集就结束了。</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/verng1_end_young_gc.png" alt="End of Yonug GC with G1"></p>
<p>G1收集器的新生代GC可以总结如下：</p>
<ul>
<li>堆区是一个单独的内存区，被分成了很多小区域。</li>
<li>新生代区由很多不连续的小区域组成，当需要的时候，重新分配新生代区的大小很容易。</li>
<li>新生代GC是stop the world的。</li>
<li>新生代GC是多现场并发进行的。</li>
<li>最后，活着的对象在survivor区或者老年代区。</li>
</ul>
<h5 id="6、Initial-Marking-Phase"><a href="#6、Initial-Marking-Phase" class="headerlink" title="6、Initial Marking Phase"></a>6、Initial Marking Phase</h5><p><img src="http://7xngpc.com1.z0.glb.clouddn.com/verng1_initial_marking_phase.png" alt="Initial Marking Phase"></p>
<h5 id="7、Concurrent-Marking-Phase"><a href="#7、Concurrent-Marking-Phase" class="headerlink" title="7、Concurrent Marking Phase"></a>7、Concurrent Marking Phase</h5><p><img src="http://7xngpc.com1.z0.glb.clouddn.com/verng1_concurrent_marking_phase.png" alt="Concurrent Marking Phase"></p>
<h5 id="8、Remark-Phase"><a href="#8、Remark-Phase" class="headerlink" title="8、Remark Phase"></a>8、Remark Phase</h5><p><img src="http://7xngpc.com1.z0.glb.clouddn.com/verng1_remark_phase.png" alt="Remark Phase"></p>
<h5 id="9、Copying-Cleanup-Phase"><a href="#9、Copying-Cleanup-Phase" class="headerlink" title="9、Copying/Cleanup Phase"></a>9、Copying/Cleanup Phase</h5><p><img src="http://7xngpc.com1.z0.glb.clouddn.com/verng1_copying_phase.png" alt="Copying/Cleanup Phase"></p>
<h5 id="10、After-Copying-Clean-Phase"><a href="#10、After-Copying-Clean-Phase" class="headerlink" title="10、After Copying/Clean Phase"></a>10、After Copying/Clean Phase</h5><p><img src="http://7xngpc.com1.z0.glb.clouddn.com/verng1_after_copying_phase.png" alt="After Copying/Clean Phase"></p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><pre><code>package com.idouba.jvm.demo;
/**
 * Use shortest code demo jvm allocation, gc, and someting in gc.
 *
 * In details
 * 1) sizing of young generation (eden space，survivor space),old generation.
 * 2) allocation in eden space, gc in young generation,
 * 3) working with survivor space and with old generation.
 *
 */
public class SimpleJVMArg {
    /**
     * @param args
     */
    public static void main(String[] args)
    {
        demo();
    }
    /**
     * VM arg：-verbose:gc -Xms200M -Xmx200M -Xmn100M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1 -XX:+PrintTenuringDistribution
     *
     */
    @SuppressWarnings(&quot;unused&quot;)
    public static void demo() {
        final int tenMB = 10* 1024 * 1024;

        byte[] alloc1, alloc2, alloc3;

        alloc1 = new byte[tenMB / 5];
        alloc2 = new byte[5 * tenMB];
        alloc3 = new byte[4 * tenMB];
        alloc3 = null;
        alloc3 = new byte[6 * tenMB];
    }
}
</code></pre><p>本实例来源于<a href="http://ifeve.com/a-simple-example-demo-jvm-allocation-and-gc/" target="_blank" rel="external">最简单例子图解JVM内存分配和回收</a></p>
<p>设置虚拟机执行参数如下：</p>
<pre><code>-verbose:gc -Xms200M -Xmx200M -Xmn100M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:+PrintTenuringDistribution
</code></pre><p>其中，<strong>-Xms200M -Xmx200M</strong>设置Java堆大小为200M，不可扩展，<br>    <strong>-Xmn100M</strong>设置其中100M分配给新生代，则剩下的100M分配给老年代。<br>    <strong>-XX:SurvivorRatio=8</strong>设置了新生代中eden与survivor的空间比例是1：8。</p>
<table><br>   <tr><br>      <td>GC 命令行选项 </td><br>      <td>描述</td><br>   </tr><br>   <tr><br>      <td>-Xms</td><br>      <td>设置Java堆大小的初始值/最小值。例如：-Xms512m (请注意这里没有”=”).</td><br>   </tr><br>   <tr><br>      <td>-Xmx</td><br>      <td>设置Java堆大小的最大值</td><br>   </tr><br>   <tr><br>      <td>-Xmn</td><br>      <td>设置新生代对空间的初始值，最小值和最大值。请注意，年老代堆空间大小是依赖于新生代堆空间大小的</td><br>   </tr><br>   <tr><br>      <td>-XX:PermSize=<n>[g|m|k]</n></td><br>      <td>设置持久代堆空间的初始值和最小值</td><br>   </tr><br></table>

<p>执行结果如下：</p>
<pre><code>[GC (Allocation Failure) [DefNew
Desired survivor size 5242880 bytes, new threshold 15 (max 15)
- age   1:    2573248 bytes,    2573248 total
: 56525K-&gt;2512K(92160K), 0.0524011 secs] 56525K-&gt;53712K(194560K), 0.0524798 secs] [Times: user=0.01 sys=0.03, real=0.05 secs] 
[GC (Allocation Failure) [DefNew
Desired survivor size 5242880 bytes, new threshold 15 (max 15)
- age   2:    2572736 bytes,    2572736 total
: 43472K-&gt;2512K(92160K), 0.0034130 secs] 94672K-&gt;53712K(194560K), 0.0034658 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 def new generation   total 92160K, used 64772K [0x03c00000, 0x0a000000, 0x0a000000)
  eden space 81920K,  76% used [0x03c00000, 0x078cce58, 0x08c00000)
  from space 10240K,  24% used [0x08c00000, 0x08e741c0, 0x09600000)
  to   space 10240K,   0% used [0x09600000, 0x09600000, 0x0a000000)
 tenured generation   total 102400K, used 51200K [0x0a000000, 0x10400000, 0x10400000)
   the space 102400K,  50% used [0x0a000000, 0x0d200010, 0x0d200200, 0x10400000)
 Metaspace       used 97K, capacity 2242K, committed 2368K, reserved 4480K
</code></pre><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li>《深入理解Java虚拟机：JVM高级特性与最佳实践》</li>
<li><a href="http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf" target="_blank" rel="external">http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf</a> java5官方文档，介绍了HotShot虚拟机的详细内容</li>
<li><a href="http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html#t1" target="_blank" rel="external">http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html#t1</a> java7关于G1收集器的详细介绍 </li>
<li><a href="http://jbutton.iteye.com/blog/1569746" target="_blank" rel="external">http://jbutton.iteye.com/blog/1569746</a></li>
<li><a href="http://www.importnew.com/1551.html" target="_blank" rel="external">http://www.importnew.com/1551.html</a></li>
<li><a href="http://ifeve.com/useful-jvm-flags-part-5-young-generation-garbage-collection/" target="_blank" rel="external">JVM实用参数（五）新生代垃圾回收</a></li>
<li><a href="http://ifeve.com/under-the-hood-runtime-data-areas-javas-memory-model/" target="_blank" rel="external">JAVA的内存模型及结构</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://vernlium.github.io/2015/08/26/Java线程转储/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Anan Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnanZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/08/26/Java线程转储/" itemprop="url">Java线程转储</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-08-26T22:14:23+08:00">
                2015-08-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天看《Java并发编程实战》中讲到通过<strong>线程转储</strong>信息来分析死锁，之前并没有听说过“线程转储”这个概念，特地搜了一下，总结如下：</p>
<h2 id="java线程转储"><a href="#java线程转储" class="headerlink" title="java线程转储"></a>java线程转储</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>java的线程转储可以被定义为JVM中在某一个给定的时刻运行的所有线程的快照。一个线程转储可能包含一个单独的线程或者多个线程。在多线程环境中，比如J2EE应用服务器，将会有许多线程和线程组。每一个线程都有它自己的调用堆栈，在一个给定时刻，表现为一个独立功能。线程转储将会提供JVM中所有线程的堆栈信息，对于特定的线程也会给出更多信息。</p>
<h3 id="生成java线程转储"><a href="#生成java线程转储" class="headerlink" title="生成java线程转储"></a>生成java线程转储</h3><p>线程转储可以通过向JVM进程发送一个SIGQUIT信号来生成。有两种不同方式来向进程发送这个信号：</p>
<ul>
<li>Windows:</li>
</ul>
<p>1.转向服务器的标准输出窗口并按下Control + Break组合键, 之后需要将线程堆栈复制到文件中；</p>
<ul>
<li>UNIX/ Linux：<br>首先查找到服务器的进程号(process id), 然后获取线程堆栈.<ol>
<li>ps –ef  | grep java</li>
<li>kill -3 <pid></pid></li>
</ol>
</li>
</ul>
<p>JVM 自带的工具获取线程堆栈:</p>
<p>JDK自带命令行工具获取PID，再获取ThreadDump:</p>
<ol>
<li>jps 或 ps –ef|grepjava (获取PID)</li>
<li>jstack [-l ]<pid> | tee -a jstack.log  (获取ThreadDump)</pid></li>
</ol>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p><strong>线程的状态分析</strong> </p>
<p>要看懂线程转储信息，线程的状态是一个重要的指标，它会显示在线程 Stacktrace的头一行结尾的地方。那么线程常见的有哪些状态呢？线程在什么样的情况下会进入这种状态呢？我们能从中发现什么线索？ </p>
<p><strong>Runnable</strong></p>
<p>该状态表示线程具备所有运行条件，在运行队列中准备操作系统的调度，或者正在运行。 </p>
<p><strong>Wait on condition</strong></p>
<p>该状态出现在线程等待某个条件的发生。具体是什么原因，可以结合 stacktrace来分析。最常见的情况是线程在等待网络的读写，比如当网络数据没有准备好读时，线程处于这种等待状态，而一旦有数据准备好读之后，线程会重新激活，读取并处理数据。在 Java引入 NewIO之前，对于每个网络连接，都有一个对应的线程来处理网络的读写操作，即使没有可读写的数据，线程仍然阻塞在读写操作上，这样有可能造成资源浪费，而且给操作系统的线程调度也带来压力。在 NewIO里采用了新的机制，编写的服务器程序的性能和可扩展性都得到提高。 </p>
<p>如果发现有大量的线程都在处在 Wait on condition，从线程 stack看， 正等待网络读写，这可能是一个网络瓶颈的征兆。因为网络阻塞导致线程无法执行。一种情况是网络非常忙，几 乎消耗了所有的带宽，仍然有大量数据等待网络读 写；另一种情况也可能是网络空闲，但由于路由等问题，导致包无法正常的到达。所以要结合系统的一些性能观察工具来综合分析，比如 netstat统计单位时间的发送包的数目，如果很明显超过了所在网络带宽的限制 ; 观察 cpu的利用率，如果系统态的 CPU时间，相对于用户态的 CPU时间比例较高；如果程序运行在 Solaris 10平台上，可以用 dtrace工具看系统调用的情况，如果观察到 read/write的系统调用的次数或者运行时间遥遥领先；这些都指向由于网络带宽所限导致的网络瓶颈。 </p>
<p>另外一种出现 Wait on condition的常见情况是该线程在 sleep，等待 sleep的时间到了时候，将被唤醒。 </p>
<p><strong> Waiting for monitor entry 和 in Object.wait()</strong></p>
<p>在多线程的 JAVA程序中，实现线程之间的同步，就要说说 Monitor。 Monitor是 Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者 Class的锁。每一个对象都有，也仅有一个 monitor。下 面这个图，描述了线程和 Monitor之间关系，以 及线程的状态转换图： </p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vernjava线程状态转换.jpg" alt="java线程状态转换"></p>
<p>从图中可以看出，<strong>每个 Monitor在某个时刻，只能被一个线程拥有，该线程就是 “Active Thread”，而其它线程都是 “Waiting Thread”，分别在两个队列 “ Entry Set”和 “Wait Set”里面等候。在 “Entry Set”中等待的线程状态是 “Waiting for monitor entry”，而在 “Wait Set”中等待的线程状态是 “in Object.wait()”。</strong> </p>
<p>先看 “Entry Set”里面的线程。我们称被 synchronized保护起来的代码段为临界区。当一个线程申请进入临界区时，它就进入了 “Entry Set”队列。对应的 code就像： </p>
<pre><code>synchronized(obj) { 
    ......... 
} 
</code></pre><p>这时有两种可能性：<br>1）该 monitor不被其它线程拥有， Entry Set里面也没有其它等待线程。本线程即成为相应类或者对象的 Monitor的 Owner，执行临界区的代码<br>2）该 monitor被其它线程拥有，本线程在 Entry Set队列中等待。 </p>
<p>在第一种情况下，线程将处于 “Runnable”的状态，而第二种情况下，线程 DUMP会显示处于 “waiting for monitor entry”。如下所示： </p>
<pre><code>&quot;Thread-0&quot; prio=10 tid=0x08222eb0 nid=0x9 waiting for monitor entry [0xf927b000 ..0xf927bdb8] 
at testthread.WaitThread.run(WaitThread.java:39) 
- waiting to lock &lt;0xef63bf08&gt; (a java.lang.Object) 
- locked &lt;0xef63beb8&gt; (a java.util.ArrayList) 
at java.lang.Thread.run(Thread.java:595) 
</code></pre><p>临界区的设置，是为了保证其内部的代码执行的原子性和完整性。但是因为临界区在任何时间只允许线程串行通过，这 和我们多线程的程序的初衷是相反的。 如果在多线程的程序中，大量使用 synchronized，或者不适当的使用了它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在线程 DUMP中发现了这个情况，应该审查源码，改进程序。 </p>
<p>现在我们再来看现在线程为什么会进入 “Wait Set”。当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃了 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll() ， “ Wait Set”队列中线程才得到机会去竞争，但是只有一个线程获得对象的 Monitor，恢复到运行态。在 “Wait Set”中的线程， DUMP中表现为： in Object.wait()，类似于： </p>
<pre><code>&quot;Thread-1&quot; prio=10 tid=0x08223250 nid=0xa in Object.wait() [0xef47a000..0xef47aa38] 
at java.lang.Object.wait(Native Method) 
- waiting on &lt;0xef63beb8&gt; (a java.util.ArrayList) 
at java.lang.Object.wait(Object.java:474) 
at testthread.MyWaitThread.run(MyWaitThread.java:40) 
- locked &lt;0xef63beb8&gt; (a java.util.ArrayList) 
at java.lang.Thread.run(Thread.java:595) 
</code></pre><p>仔细观察上面的 DUMP信息，你会发现它有以下两行： </p>
<ul>
<li>locked <0xef63beb8> (a java.util.ArrayList) </0xef63beb8></li>
<li>waiting on <0xef63beb8> (a java.util.ArrayList) </0xef63beb8></li>
</ul>
<p>这里需要解释一下，为什么先 lock了这个对象，然后又 waiting on同一个对象呢？让我们看看这个线程对应的代码： </p>
<pre><code>synchronized(obj) { 
       ......... 
       obj.wait(); 
       ......... 
} 
</code></pre><p>线程的执行中，先用 synchronized 获得了这个对象的 Monitor（对应于 locked <0xef63beb8> ）。当执行到 obj.wait(), 线程即放弃了 Monitor的所有权，进入 “wait set”队列（对应于 waiting on <0xef63beb8> ）。 </0xef63beb8></0xef63beb8></p>
<h2 id="分析一个Java线程"><a href="#分析一个Java线程" class="headerlink" title="分析一个Java线程"></a>分析一个Java线程</h2><p>为了可以理解/分析线程转储，首先要理解线程转储的各个部分。让我们先拿一个简单的线程堆栈为例，并且去了解他的每个部分。</p>
<pre><code>&quot;ExecuteThread: &apos;1&apos; &quot; daemon prio=5 tid=0x628330 nid=0xf runnable [0xe4881000..0xe48819e0]
at com.vantive.vanjavi.VanJavi.VanCreateForm(Native Method)
at com.vantive.vanjavi.VanMain.open(VanMain.java:53)
at jsp_servlet._so.__newServiceOrder.printSOSection( __newServiceOrder.java:3547)
at jsp_servlet._so.__newServiceOrder._jspService (__newServiceOrder.java:5652)
at weblogic.servlet.jsp.JspBase.service(JspBase.java:27)
at weblogic.servlet.internal.ServletStubImpl.invokeServlet (ServletStubImpl.java:265)
at weblogic.servlet.internal.ServletStubImpl.invokeServlet (ServletStubImpl.java:200)
at weblogic.servlet.internal.WebAppServletContext.invokeServlet (WebAppServletContext.java:2495)
at weblogic.servlet.internal.ServletRequestImpl.execute (ServletRequestImpl.java:2204)
at weblogic.kernel.ExecuteThread.execute (ExecuteThread.java:139)
at weblogic.kernel.ExecuteThread.run(ExecuteThread.java:120)

In the above Thread Dump, the interesting part to is the first line. The rest of the stuff is nothing more than a general stack trace. Lets analyze the first line here
</code></pre><p>各个项的含义为：</p>
<ul>
<li>Execute Thread : 1 说明了线程的名字</li>
<li>daemon 表明这个线程是一个守护线程</li>
<li>prio=5 线程的优先级 (默认是5)</li>
<li>tid：Java的线程Id (这个线程在当前虚拟机中的唯一标识).</li>
<li>nid 线程本地标识. 也就是Solaris中的LWP，线程在操作系统中的标识</li>
<li>runnable 线程的状态 (参考上面的)</li>
<li>[x..y] 当前运行的线程在堆中的地址范围</li>
</ul>
<p>这个线程转储的剩余部分是调用堆栈。在这个例子中，这个线程（Execute Thread 1）是操作系统守护线程，当前正在执行一个本地方法vanCreateForm()。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.<a href="http://www.cnblogs.com/huangfox/p/3442746.html" target="_blank" rel="external">http://www.cnblogs.com/huangfox/p/3442746.html</a></p>
<p>2.Javadoc关于ThreadDump的介绍<a href="https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/using_threaddumps.html" target="_blank" rel="external">https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/using_threaddumps.html</a></p>
<p>3.<a href="https://sites.google.com/site/threaddumps/java-thread-dumps-2" target="_blank" rel="external">https://sites.google.com/site/threaddumps/java-thread-dumps-2</a></p>
<p>4.<a href="http://blog.csdn.net/rachel_luo/article/details/8920596" target="_blank" rel="external">http://blog.csdn.net/rachel_luo/article/details/8920596</a></p>
<p>5.<a href="http://blog.csdn.net/wanyanxgf/article/details/6944987" target="_blank" rel="external">http://blog.csdn.net/wanyanxgf/article/details/6944987</a></p>
<p><strong>4、5的文章中有更详细的介绍和例子分析</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://vernlium.github.io/2015/07/29/Java代理模式-Proxy类的使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Anan Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnanZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/07/29/Java代理模式-Proxy类的使用/" itemprop="url">Java代理模式-Proxy类的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-29T20:51:50+08:00">
                2015-07-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>敬请期待</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://vernlium.github.io/2015/07/28/Intellij-IDEA省电模式是个什么鬼？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Anan Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnanZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/07/28/Intellij-IDEA省电模式是个什么鬼？/" itemprop="url">Intellij IDEA省电模式是个什么鬼？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-28T20:55:44+08:00">
                2015-07-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>刚转入IDEA阵营，这两天idea出现了一个很奇怪的现象：代码中的类不会自动提示导入。尝试了各种设置依然无效，还有类前面是一个j图标而不是常见的C图标。写代码效率骤降，各种烦，要死的心都有了。最后在一个博客中看到了解决方案：<a href="http://blog.csdn.net/Admin_/article/details/46945059" target="_blank" rel="external">http://blog.csdn.net/Admin_/article/details/46945059</a></p>
<p>这个文章中讲的是Android Studio，Android Studio就是基于idea的。原来是idea的省电模式惹的祸。</p>
<p>idea竟然还有这个奇怪的省电模式，不知道什么时候自己手贱把它给打开了，关闭之后整个世界都明亮了。</p>
<p>这个还是比较适合开会的时候无聊看代码用的，又省电又不影响你看代码。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://vernlium.github.io/2015/07/22/Java序列化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Anan Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnanZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/07/22/Java序列化/" itemprop="url">Java序列化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-22T21:12:43+08:00">
                2015-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我在看程序的时候，经常会看到一些类实现了”Serializable”接口，一直对这个接口很奇怪，不知道它的作用是什么，今天专门查了一下资料，总结如下。</p>
<h2 id="1、为什么要序列化？"><a href="#1、为什么要序列化？" class="headerlink" title="1、为什么要序列化？"></a>1、为什么要序列化？</h2><p>在程序中，创建一个java对象，这个对象会随着程序的终止而消亡。但是在一些情况下，如果对象能够在程序不运行的情况下仍能存在并保存其信息，将非常有用。这样，在下次运行程序时，该对象将被重建并且拥有的信息与在程序上次运行是它所拥有的信息相同。</p>
<h2 id="2、序列化是干什么的？"><a href="#2、序列化是干什么的？" class="headerlink" title="2、序列化是干什么的？"></a>2、序列化是干什么的？</h2><p>简单说就是为了保存在内存中的各种对象的状态（也就是成员变量，不是方法），并且可以把保存的对象状态再读出来。</p>
<p>Java对象的序列化将那些实现了<strong>Serializable</strong>接口的对象转换成一个字节序列，并能够在以后将这个字节序列完全恢复为原来的对象。</p>
<p>序列化分为两大部分：序列化和反序列化。序列化是这个过程的第一部分，将数据分解成字节流，以便存储在文件中或在网络上传输。反序列化就是打开字节流并重构对象。对象序列化不仅要将基本数据类型转换成字节表示，有时还要恢复数据。恢复数据要求有恢复数据的对象实例。ObjectOutputStream中的序列化过程与字节流连接，包括对象类型和版本信息。反序列化时，JVM用头信息生成对象实例，然后将对象字节流中的数据复制到对象数据成员中。</p>
<h2 id="3、什么情况下需要序列化"><a href="#3、什么情况下需要序列化" class="headerlink" title="3、什么情况下需要序列化"></a>3、什么情况下需要序列化</h2><p>对象序列化的概念加入到语言中是为了支持两种主要特性：</p>
<ul>
<li>远程方法调用（RMI），它使存活于其他计算机上的对象使用起来就像是存活着本地上一样。当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值。</li>
<li>Java Beans。使用一个Bean时，一般情况下在设计阶段对它的状态信息进行配置。这种状态信息必须保存下来，并在程序启动进行后期恢复，这种具体工具就由序列化完成的。</li>
</ul>
<h2 id="4、相关注意事项"><a href="#4、相关注意事项" class="headerlink" title="4、相关注意事项"></a>4、相关注意事项</h2><ul>
<li>a）序列化时，只对对象的状态进行保存，而不管对象的方法；</li>
<li>b）当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；</li>
<li>c）当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</li>
<li>d）并非所有的对象都可以序列化，,至于为什么不可以，有很多原因了,比如：<ul>
<li>d.1.安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输 等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。</li>
<li>d.2. 资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分 配，而且，也是没有必要这样实现。</li>
</ul>
</li>
</ul>
<h2 id="5、如何进行序列化？"><a href="#5、如何进行序列化？" class="headerlink" title="5、如何进行序列化？"></a>5、如何进行序列化？</h2><p>要序列化一个对象，首先创建OutputStream对象，然后将其封装在一个ObjectOutputStream对象中。这时，只需调用writeObject()即可将对象序列化，并将其发送给OutputStream(对象序列化是基于字节的，所以要使用InputStream和OutputStream继承层次结构)。要进行反序列化，需要将一个InputStream封装在ObjectInputStream中，然后调用readObject()。最后获得一个引用，它指向一个向上转型的Object，所以必须向下转型才能直接设置它们。</p>
<p>要注意的是：只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常。</p>
<p>实例如下：</p>
<p>Student类定义如下：</p>
<pre><code>import java.io.Serializable;  

public class Student implements Serializable  
{  
    private String name;  
    private char sex;  
    private int year;  
    private double gpa;  

    public Student()  {
        System.out.println(&quot;Student constructor&quot;); 
    }  

    public Student(String name,char sex,int year,double gpa)  {  
        System.out.println(&quot;Student constructor with:&quot;+name+&quot; &quot;+sex+&quot; &quot;+year+&quot; &quot;+gpa);
        this.name = name;   
        this.sex = sex;  
        this.year = year;  
        this.gpa = gpa;  
    }  

    public void setName(String name)  {  
        this.name = name;  
    }  

    public void setSex(char sex)  {  
        this.sex = sex;  
    }  

    public void setYear(int year)  {  
        this.year = year;  
    }  

    public void setGpa(double gpa)  {  
        this.gpa = gpa;  
    }  

    public String getName()  {  
        return this.name;  
    }  

    public char getSex()  {  
        return this.sex;  
    }  

    public int getYear()  {  
        return this.year;  
    }  

    public double getGpa()  {  
        return this.gpa;  
    }  
}  
</code></pre><p>把Student类的对象序列化到文件student.txt，并从该文件中反序列化，向console显示结果。代码如下：</p>
<pre><code>import java.io.*;  

public class UseStudent  
{  
    public static void main(String[] args)  
    {  
        Student st = new Student(&quot;Tom&quot;,&apos;M&apos;,20,3.6);  
        File file = new File(&quot;student.txt&quot;);  
        try  
        {  
         file.createNewFile();  
        }  
        catch(IOException e)  
        {  
         e.printStackTrace();  
        }  
        try  
        {  
         //Student对象序列化过程  
         FileOutputStream fos = new FileOutputStream(file);  
         ObjectOutputStream oos = new ObjectOutputStream(fos);  
         oos.writeObject(st);  
         oos.flush();  
         oos.close();  
         fos.close();  

         //Student对象反序列化过程  
         FileInputStream fis = new FileInputStream(file);  
         ObjectInputStream ois = new ObjectInputStream(fis);  
         Student st1 = (Student) ois.readObject();  
         System.out.println(&quot;name = &quot; + st1.getName());  
         System.out.println(&quot;sex = &quot; + st1.getSex());  
         System.out.println(&quot;year = &quot; + st1.getYear());  
         System.out.println(&quot;gpa = &quot; + st1.getGpa());  
         ois.close();  
         fis.close();  
        }  
        catch(ClassNotFoundException e)  
        {  
         e.printStackTrace();  
        }  
        catch (IOException e)  
        {  
         e.printStackTrace();  
        }               
    }  
} 
</code></pre><p>结果如下所示：</p>
<pre><code>name = Tom
sex = M
year = 20
gpa = 3.6
</code></pre><p>注意:在对一个Serializable对象进行还原的过程中，没有调用任何构造器，包括默认的构造器。整个对象都是通过从InputStream中取得数据恢复而来。</p>
<h3 id="5-1、Externalizable"><a href="#5-1、Externalizable" class="headerlink" title="5.1、Externalizable"></a>5.1、Externalizable</h3><p>有时，要考虑特殊的安全问题，不希望对象的某一部分被序列化，或者一个对象被还原以后，某个子对象需要重新创建，而不必将该子对象序列化。</p>
<p>在这些特殊情况下，可以通过实现Externalizable接口——代替实现Serializable接口——来对序列化过程进行控制。这个Externalizable接口继承了Serializable接口，同时增添了两个方法：writeExternal()和readExternal()。这两个方法会在序列化和反序列化还原的过程中被自动调用，以便执行一些特殊操作。</p>
<pre><code>//: io/Blips.java
// Simple use of Externalizable &amp; a pitfall.
import java.io.*;
import static net.mindview.util.Print.*;

class Blip1 implements Externalizable {
  public Blip1() {
    print(&quot;Blip1 Constructor&quot;);
  }
  public void writeExternal(ObjectOutput out)
      throws IOException {
    print(&quot;Blip1.writeExternal&quot;);
  }
  public void readExternal(ObjectInput in)
     throws IOException, ClassNotFoundException {
    print(&quot;Blip1.readExternal&quot;);
  }
}

class Blip2 implements Externalizable {
  Blip2() {
    print(&quot;Blip2 Constructor&quot;);
  }
  public void writeExternal(ObjectOutput out)
      throws IOException {
    print(&quot;Blip2.writeExternal&quot;);
  }
  public void readExternal(ObjectInput in)
     throws IOException, ClassNotFoundException {
    print(&quot;Blip2.readExternal&quot;);
  }
}

public class Blips {
  public static void main(String[] args)
  throws IOException, ClassNotFoundException {
    print(&quot;Constructing objects:&quot;);
    Blip1 b1 = new Blip1();
    Blip2 b2 = new Blip2();
    ObjectOutputStream o = new ObjectOutputStream(
      new FileOutputStream(&quot;Blips.out&quot;));
    print(&quot;Saving objects:&quot;);
    o.writeObject(b1);
    o.writeObject(b2);
    o.close();
    // Now get them back:
    ObjectInputStream in = new ObjectInputStream(
      new FileInputStream(&quot;Blips.out&quot;));
    print(&quot;Recovering b1:&quot;);
    b1 = (Blip1)in.readObject();
    // OOPS! Throws an exception:
    //! print(&quot;Recovering b2:&quot;);
    //! b2 = (Blip2)in.readObject();
  }
} 
</code></pre><p>结果为：</p>
<pre><code>/* Output:
Constructing objects:
Blip1 Constructor
Blip2 Constructor
Saving objects:
Blip1.writeExternal
Blip2.writeExternal
Recovering b1:
Blip1 Constructor
Blip1.readExternal
*///:~
</code></pre><p>例中没有恢复Blip2对象，因为这样做会导致一个异常。这是因为：Blip1的构造器是public，而Blip2的构造器却不是，这样就会在恢复时造成异常。</p>
<p>恢复b1后，会调用Blip1默认构造器。这与恢复一个Serializable对象不同。对于Serializable对象，对象完全以它存储的二进制位为基础来构造，而不调用构造器。而对于一个Externalizable对象，所有普通的默认构造器都会被调用（包括在字段定义时的初始化），然后调用readExternal()。必须主要到：所有默认的构造器都会被调用，才能使Externalizable对象产生正确的行为。</p>
<pre><code>//: io/Blip3.java
// Reconstructing an externalizable object.
import java.io.*;
import static net.mindview.util.Print.*;

public class Blip3 implements Externalizable {
  private int i;
  private String s; // No initialization
  public Blip3() {
    print(&quot;Blip3 Constructor&quot;);
    // s, i not initialized
  }
  public Blip3(String x, int a) {
    print(&quot;Blip3(String x, int a)&quot;);
    s = x;
    i = a;
    // s &amp; i initialized only in non-default constructor.
  }
  public String toString() { return s + i; }
  public void writeExternal(ObjectOutput out) throws IOException {
    print(&quot;Blip3.writeExternal&quot;);
    // You must do this:
    out.writeObject(s);
    out.writeInt(i);
  }
  public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
    print(&quot;Blip3.readExternal&quot;);
    // You must do this:
    s = (String)in.readObject();
    i = in.readInt();
  }
  public static void main(String[] args) throws IOException, ClassNotFoundException {
    print(&quot;Constructing objects:&quot;);
    Blip3 b3 = new Blip3(&quot;A String &quot;, 47);
    print(b3);
    ObjectOutputStream o = new ObjectOutputStream(
      new FileOutputStream(&quot;Blip3.out&quot;));
    print(&quot;Saving object:&quot;);
    o.writeObject(b3);
    o.close();
    // Now get it back:
    ObjectInputStream in = new ObjectInputStream(
      new FileInputStream(&quot;Blip3.out&quot;));
    print(&quot;Recovering b3:&quot;);
    b3 = (Blip3)in.readObject();
    print(b3);
  }
} 
</code></pre><p>结果为：</p>
<pre><code>/* Output:
Constructing objects:
Blip3(String x, int a)
A String 47
Saving object:
Blip3.writeExternal
Recovering b3:
Blip3 Constructor
Blip3.readExternal
A String 47
*///:~
</code></pre><p>字段s和i只在第二个构造器中初始化，而不是在默认的构造器中初始化。这意味着假如不在readExternal()中初始化s和i，s就会为null，而i就会为0。如果注释掉跟随于”You must do this“后面的两行代码，当对象被还原后,s是null,而i为0。</p>
<p>如果从Externalizable对象继承，通常需要调用基类版本的writeExternal()和readExternal()来为基类组件提供恰当的存储和恢复功能。</p>
<p>因此，为了正常运行，不仅需要在writeExternal()方法中将来自对象的重要信息写入，还必须在readExternal()方法中恢复数据。</p>
<h3 id="5-2、transient关键字"><a href="#5-2、transient关键字" class="headerlink" title="5.2、transient关键字"></a>5.2、transient关键字</h3><p>当某个字段被声明为transient后，默认序列化机制就会忽略该字段。</p>
<pre><code>import java.util.concurrent.*;
import java.io.*;
import java.util.*;
import static net.mindview.util.Print.*;

public class Logon implements Serializable {
  private Date date = new Date();
  private String username;
  private transient String password;
  public Logon(String name, String pwd) {
    username = name;
    password = pwd;
  }
  public String toString() {
    return &quot;logon info: \n   username: &quot; + username +
      &quot;\n   date: &quot; + date + &quot;\n   password: &quot; + password;
  }
  public static void main(String[] args) throws Exception {
    Logon a = new Logon(&quot;Hulk&quot;, &quot;myLittlePony&quot;);
    print(&quot;logon a = &quot; + a);
    ObjectOutputStream o = new ObjectOutputStream(
      new FileOutputStream(&quot;Logon.out&quot;));
    o.writeObject(a);
    o.close();
    TimeUnit.SECONDS.sleep(1); // Delay
    // Now get them back:
    ObjectInputStream in = new ObjectInputStream(
      new FileInputStream(&quot;Logon.out&quot;));
    print(&quot;Recovering object at &quot; + new Date());
    a = (Logon)in.readObject();
    print(&quot;logon a = &quot; + a);
  }
} 
</code></pre><p>结果为：</p>
<pre><code>/* Output: (Sample)
logon a = logon info:
   username: Hulk
   date: Sat Nov 19 15:03:26 MST 2005
   password: myLittlePony
Recovering object at Sat Nov 19 15:03:28 MST 2005
logon a = logon info:
   username: Hulk
   date: Sat Nov 19 15:03:26 MST 2005
   password: null
*///:~
</code></pre><p>password是transient的，所以不会被自动保存到磁盘。另外，自动序列化机制也不会尝试恢复它。当对象被恢复时，password就变成了null。</p>
<p>由于Externalizable对象在默认情况下不保存它们的任何字段，所以transient关键字只能和Serializable对象一起使用。</p>
<h3 id="5-3、Externalizable的替代方法"><a href="#5-3、Externalizable的替代方法" class="headerlink" title="5.3、Externalizable的替代方法"></a>5.3、Externalizable的替代方法</h3><p>实现Serializable接口，并添加（是添加，不是覆盖或实现）名为writeObject()和readObject()的方法。这样一旦对象被序列化或者被反序列化还原，就会自动的分别调用这两个方法。也就是所，只要提供这两个方法，就会使用它们而不是默认的序列化机制。</p>
<p>这些方法必须具有准确的方法特征签名：</p>
<pre><code>private void writeObject(ObjectOutputStream stream) throws IOException;

private void readObject(ObjectInputStream stream) 
throws IOException,ClassNotFoundException;
</code></pre><p>在调用ObjectOutputStream.writeObject()时，会检查所传递的Serializable对象，看看是否实现了自己的writeObject()。如果是这样，就跳到正常的序列化过程并调用它的writeObject()。readObject()的情形与此相同。</p>
<p>在writeObject()内部，可以调用defaultWriteObject()来选择执行默认的writeObject()。类似的，在readObject()内部，可以调用defaultReadObject()。</p>
<pre><code>//: io/SerialCtl.java
// Controlling serialization by adding your own
// writeObject() and readObject() methods.
import java.io.*;

public class SerialCtl implements Serializable {
  private String a;
  private transient String b;
  public SerialCtl(String aa, String bb) {
    a = &quot;Not Transient: &quot; + aa;
    b = &quot;Transient: &quot; + bb;
  }
  public String toString() { return a + &quot;\n&quot; + b; }
  private void writeObject(ObjectOutputStream stream)
  throws IOException {
    stream.defaultWriteObject();
    stream.writeObject(b);
  }
  private void readObject(ObjectInputStream stream)
  throws IOException, ClassNotFoundException {
    stream.defaultReadObject();
    b = (String)stream.readObject();
  }
  public static void main(String[] args)
  throws IOException, ClassNotFoundException {
    SerialCtl sc = new SerialCtl(&quot;Test1&quot;, &quot;Test2&quot;);
    System.out.println(&quot;Before:\n&quot; + sc);
    ByteArrayOutputStream buf= new ByteArrayOutputStream();
    ObjectOutputStream o = new ObjectOutputStream(buf);
    o.writeObject(sc);
    // Now get it back:
    ObjectInputStream in = new ObjectInputStream(
      new ByteArrayInputStream(buf.toByteArray()));
    SerialCtl sc2 = (SerialCtl)in.readObject();
    System.out.println(&quot;After:\n&quot; + sc2);
  }
} 
</code></pre><p>结果为：</p>
<pre><code>/* Output:
Before:
Not Transient: Test1
Transient: Test2
After:
Not Transient: Test1
Transient: Test2
*///:~
</code></pre><p>这个例子证明transient字段并非由defaultWriteObject()方法保存，而transient字段必须在程序中明确保存和恢复。</p>
<p>如果要使用默认机制写入对象的非transient部分，那么必须调用defaultWriteObject()作为writeObject()中的第一个操作，并让defaultReadObject()作为readObject()中的第一个操作。</p>
<h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><p>1）Java序列化就是把对象转换成字节序列，而Java反序列化就是把字节序列还原成Java对象。</p>
<p>2）采用Java序列化与反序列化技术，一是可以实现数据的持久化，在MVC模式中很是有用；二是可以对象数据的远程通信。</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>1.《Thinking in Java》</p>
<p>2.<a href="http://blog.csdn.net/wangloveall/article/details/7992448" target="_blank" rel="external">http://blog.csdn.net/wangloveall/article/details/7992448</a></p>
<p>3.<a href="http://www.blogjava.net/jiangshachina/archive/2012/02/13/369898.html" target="_blank" rel="external">http://www.blogjava.net/jiangshachina/archive/2012/02/13/369898.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://vernlium.github.io/2015/07/08/java并发总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Anan Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnanZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/07/08/java并发总结/" itemprop="url">java并发总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-07-08T15:54:26+08:00">
                2015-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="1-基本的线程机制"><a href="#1-基本的线程机制" class="headerlink" title="1 基本的线程机制"></a>1 基本的线程机制</h3><h4 id="1-1-定义任务"><a href="#1-1-定义任务" class="headerlink" title="1.1 定义任务"></a>1.1 定义任务</h4><ul>
<li>实现Runnable接口并编写run()方法。</li>
</ul>
<p>Thread.yield()方法的作用是：对线程调度器的一种建议,此时可以切换给其他任务执行。这完全是选择性的。</p>
<ul>
<li>将Runnable对象交给一个Thread构造器。调用Thread对象的start()为该线程执行必需的初始化操作，然后调用Runnable的run()方法。start()调用后迅速返回。</li>
</ul>
<h4 id="1-2-使用Executor"><a href="#1-2-使用Executor" class="headerlink" title="1.2 使用Executor"></a>1.2 使用Executor</h4><p>java.util.concurrent包中的执行器(Executor)可以管理Thread对象。Executor可以管理异步任务的执行，而无须显式的管理线程的生命周期。Executor是Java SE5/6中启动任务的优选方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedThreadPool</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</div><div class="line">            exec.execute(<span class="keyword">new</span> LifeOff());</div><div class="line">        exec.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调用shutdown()方法可以防止新任务被提交给这个Executor,当前线程将继续运行在shutdown()被调用之前提交的所有任务。</p>
<h4 id="Executors的可以返回ExecutorService的几个方法比较："><a href="#Executors的可以返回ExecutorService的几个方法比较：" class="headerlink" title="Executors的可以返回ExecutorService的几个方法比较："></a>Executors的可以返回ExecutorService的几个方法比较：</h4><p><strong>newFixedThreadPool</strong></p>
<p>public static ExecutorService newFixedThreadPool(int nThreads)</p>
<p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。 </p>
<p>参数：</p>
<p>nThreads - 池中的线程数 </p>
<p>返回：</p>
<p>新创建的线程池 </p>
<p>抛出： </p>
<p>IllegalArgumentException - 如果 nThreads &lt;= 0</p>
<hr>
<p><strong>newFixedThreadPool</strong></p>
<p>public static ExecutorService newFixedThreadPool(int nThreads,ThreadFactory threadFactory)</p>
<p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程，在需要时使用提供的 ThreadFactory 创建新线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。 </p>
<p>参数：</p>
<p>nThreads - 池中的线程数</p>
<p>threadFactory - 创建新线程时使用的工厂 </p>
<p>返回：</p>
<p>新创建的线程池 </p>
<p>抛出： </p>
<p>NullPointerException - 如果 threadFactory 为 null </p>
<p>IllegalArgumentException - 如果 nThreads &lt;= 0</p>
<hr>
<p><strong>newSingleThreadExecutor</strong></p>
<p>public static ExecutorService newSingleThreadExecutor()</p>
<p>创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool(1) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。 </p>
<p>返回：</p>
<p>新创建的单线程 Executor</p>
<hr>
<p><strong>newSingleThreadExecutor</strong></p>
<p>public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory)</p>
<p>创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程，并在需要时使用提供的 ThreadFactory 创建新线程。与其他等效的 newFixedThreadPool(1, threadFactory) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。 </p>
<p>参数：</p>
<p>threadFactory - 创建新线程时使用的工厂 </p>
<p>返回：</p>
<p>新创建的单线程 Executor </p>
<p>抛出： </p>
<p>NullPointerException - 如果 threadFactory 为 null</p>
<hr>
<p><strong>newCachedThreadPool</strong></p>
<p>public static ExecutorService newCachedThreadPool()</p>
<p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。注意，可以使用 ThreadPoolExecutor 构造方法创建具有类似属性但细节不同（例如超时参数）的线程池。 </p>
<p>返回：</p>
<p>新创建的线程池</p>
<hr>
<p><strong>newCachedThreadPool</strong></p>
<p>public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)</p>
<p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。 </p>
<p>参数：<br>threadFactory - 创建新线程时使用的工厂 </p>
<p>返回：</p>
<p>新创建的线程池 </p>
<p>抛出： </p>
<p>NullPointerException - 如果 threadFactory 为 null</p>
<hr>
<p>CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时创建新线程，因此它是合理的Exector的首选。</p>
<h4 id="1-3-从任务中产生返回值"><a href="#1-3-从任务中产生返回值" class="headerlink" title="1.3 从任务中产生返回值"></a>1.3 从任务中产生返回值</h4><p>Runnable是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成时能够返回一个值，那么可以实现Callable接口而不是Runnable接口。</p>
<p>Callable是一种具有类型参数的泛型，它的类型参数表示的是从方法call()中的返回值，并且必须使用ExecutorService.submit()方法调用它。</p>
<p>submit()方法会产生Future对象，它用Callable返回结果的特定类型进行了参数化。可以使用isDone()方法来查询Future是否已经完成。当任务完成时，它具有一个结果，可以调用get()方法来获取该结果。也可以不用isDone()进行检查就直接调用get()，在这种情况下，get()将阻塞直到结果准备就绪。</p>
<h4 id="1-4-休眠"><a href="#1-4-休眠" class="headerlink" title="1.4 休眠"></a>1.4 休眠</h4><p>调用sleep()，这将使任务中止执行给定的时间。</p>
<h4 id="1-5-优先级"><a href="#1-5-优先级" class="headerlink" title="1.5 优先级"></a>1.5 优先级</h4><p>线程的<strong>优先级</strong>将该线程的重要性传递给了调度器，调度器将倾向于让优先级最高的线程先执行，但是是不确定的，这并不意味着优先级较低的线程将得不到执行。优先级较低的线程仅仅是执行的频率较低。</p>
<h4 id="1-6-让步"><a href="#1-6-让步" class="headerlink" title="1.6 让步"></a>1.6 让步</h4><p>通过调用yield()方法暗示线程：你的工作做得的差不多了，可以让别的线程使用CPU了。当yield()调用时，也是在建议具有相同优先级的其他线程可以运行。</p>
<h4 id="1-7-后台（daemon）线程"><a href="#1-7-后台（daemon）线程" class="headerlink" title="1.7 后台（daemon）线程"></a>1.7 后台（daemon）线程</h4><p>后台（daemon）线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。</p>
<p>在线程启动之前调用sertDaemon()方法，可以把线程设置为后台线程。</p>
<p>后台进程在不执行finally子句的情况下就会终止其run()方法。</p>
<h4 id="1-8-加入一个线程"><a href="#1-8-加入一个线程" class="headerlink" title="1.8 加入一个线程"></a>1.8 加入一个线程</h4><p>一个线程可以在其他线程之上调用join()方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某个线程在另一个线程t上调用t.join()，此线程将被挂起，直到目标线程t结束才恢复（即t.isAlive()返回false）。</p>
<p>也可以在调用join()方法时带上一个超时参数，如果目标线程在这段时间到期时还没有结束的话，join()方法总能返回。</p>
<p>对join()方法的调用可以被中断，做法是在调用线程上调用interrupt()方法，这时需要用到try-catch子句。</p>
<h4 id="1-9-捕获异常"><a href="#1-9-捕获异常" class="headerlink" title="1.9 捕获异常"></a>1.9 捕获异常</h4><p>由于线程的本质特性，无法捕获从线程中逃逸的异常。一旦异常逃出任务的run()方法，它就会向外传播到控制台。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class ExceptionThread implements Runnable&#123;</div><div class="line">    public void run()&#123;</div><div class="line">        throw new RuntimeException();</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line">        exec.execute(new ExceptionThread());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;pool-1-thread-1&quot; java.lang.RuntimeException</div><div class="line">··at com.anan.p21.ExceptionThread.run(ExceptionThread.java:8)</div><div class="line">··at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)</div><div class="line">··at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)</div><div class="line">··at java.lang.Thread.run(Unknown Source)</div></pre></td></tr></table></figure>
<p>将main的主体放到try-catch语句块中没有作用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> calss NaiveExceptionHandling&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">            <span class="keyword">try</span>&#123;</div><div class="line">                ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line">            exec.execute(<span class="keyword">new</span> ExceptionThread());</div><div class="line">        &#125;<span class="keyword">catch</span>(RuntimeException e)&#123;</div><div class="line">                System.out.println(<span class="string">"Execption has been handled"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这将产生和前面一样的效果：未捕获异常。</p>
<p>为了解决这个问题，要修改Executor产生线程的方式。使用Thread.UncaughtExceptionHandler接口，它允许在每个Thread对象上附着一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException()会在线程因未捕获的异常而临近死亡时被调用。</p>
<h3 id="2-共享受限资源"><a href="#2-共享受限资源" class="headerlink" title="2.共享受限资源"></a>2.共享受限资源</h3><h4 id="2-1synchronized关键字"><a href="#2-1synchronized关键字" class="headerlink" title="2.1synchronized关键字"></a>2.1synchronized关键字</h4><p>当任务要执行被synchronized关键字保护的代码片段时，它将检查锁是否可用，然后获取锁，执行代码，释放锁。</p>
<p>注意：synchronized关键字不属于方法特征签名的组成部分，所以可以在覆盖方法的时候加上去。</p>
<h4 id="2-2-使用显式的Lock对象"><a href="#2-2-使用显式的Lock对象" class="headerlink" title="2.2 使用显式的Lock对象"></a>2.2 使用显式的Lock对象</h4><p>Locks对象必须被显式的创建、锁定和释放。</p>
<p>其通用用法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        doing something...</div><div class="line">        <span class="comment">//the return must be in there</span></div><div class="line">    &#125;<span class="keyword">finally</span>&#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用synchronized关键字时，需要的代码少，并且用户错误出现的可能性也会降低，因此通常只有在解决特殊问题时，才使用显式的Lock对象。比如，用synchronized关键字不能尝试着获取锁且最终获取锁会失败，或者尝试着获取锁一段时间然后放弃它，要实现这些必须使用Lock对象。</p>
<h4 id="2-3-原子性与易变性"><a href="#2-3-原子性与易变性" class="headerlink" title="2.3 原子性与易变性"></a>2.3 原子性与易变性</h4><p>原子操作是不能被线程调度机制中断的操作。</p>
<p>volatile关键字确保了应用中的可视性。如果将一个域声明为volatile的，那么只要对这个域产生了写操作，那么所有的读操作就都可以看到这个修改。即使使用了本地缓存，情况也一样，volatile域会立即被写入到主存中，而读取操作就发生在主存中。</p>
<p>非volatile域上的原子操作不必刷新到主存中去，因此其他读取该域的任务也不必看到这个新值。如果多个任务在同时访问某个域，那么这个域就应该是volatile的，否则这个域就应该只能经由同步来访问。同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来防护，那就不必将其设置为volatile的。</p>
<p>使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域。</p>
<h4 id="2-4-原子类"><a href="#2-4-原子类" class="headerlink" title="2.4 原子类"></a>2.4 原子类</h4><p>Java SE5中引入了AtomicInteger、AtomicLong、AtomicReference等特殊的原子性变量类，可以实现如下的方法进行原子性条件更新操作：</p>
<pre><code>boolean compareAndSet(expectedValue,updateValue);
</code></pre><p>Atomic类只用在特殊情况下才使用，通常依赖于锁要更安全一些。</p>
<h4 id="2-5-临界区"><a href="#2-5-临界区" class="headerlink" title="2.5 临界区"></a>2.5 临界区</h4><p>使用synchronized关键字来建立临界区（critical section）</p>
<pre><code>synchronized(syncObject){
    //This code can be accessed by only one task at a time
}
</code></pre><p>这也被称为同步控制块，在进入此代码前，必须得到syncObject对象的锁。如果其他线程已经得到了这个锁，那么就要等锁被释放后才能进入临界区。</p>
<h4 id="2-6-线程本地存储"><a href="#2-6-线程本地存储" class="headerlink" title="2.6 线程本地存储"></a>2.6 线程本地存储</h4><p>线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程都创建不同的存储。</p>
<p>ThreadLocal<t>类提供了线程局部 (thread-local) 变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。 get()方法将返回与其线程相关联的对象的副本，而set()会将参数插入到为其线程存储的对象中，并返回存储的原有对象。</t></p>
<h3 id="3-终结任务"><a href="#3-终结任务" class="headerlink" title="3 终结任务"></a>3 终结任务</h3><p>ExecutorService.awaitTermination()等待每个任务结束，如果所有的任务在超时时间到达之前结束，则返回true,否则返回false，表示不是所有的任务都已经结束了。</p>
<h4 id="在阻塞时终结"><a href="#在阻塞时终结" class="headerlink" title="在阻塞时终结"></a>在阻塞时终结</h4><p>线程的五种状态：</p>
<ul>
<li>1.<strong>新建(new)</strong>:当线程被创建时，它只会短暂的处于这种状态。此时它已经分配了必需的系统资源，并执行了初始化。此刻线程已经有资格获取CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞状态。 </li>
<li>2.<strong>就绪(Runnable)</strong>:在这种状态下，只要调度器把时间片分配给线程，线程就可以运行了。在任意时刻，线程可以运行也可以不运行，只要调度器能分配时间片给线程，它就可以运行；这不同于死亡和阻塞状态。</li>
<li>3.<strong>运行(Running)</strong>。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。 </li>
<li>4.<strong>阻塞(Blocked)</strong>:线程能够运行，但有某个条件阻止它的运行。当线程处于阻塞状态时，调度器将忽略线程，不会分配给线程任何CPU时间。直到线程重新进入了就绪状态，它才有可能执行操作。</li>
<li>5.<strong>死亡(Dead)</strong>:处于死亡或终止状态的线程将不再是可调度的，并且再不会得到CPU时间，它的任务已结算，或不再是可运行的。任务死亡的通常方式是从run()方法返回，但是任务的线程还可以被中断。</li>
</ul>
<p>其状态转换关系如下图：</p>
<p><img src="http://7xngpc.com1.z0.glb.clouddn.com/vernjava线程状态转换.jpg" alt="java线程状态转换"></p>
<h4 id="进入阻塞状态"><a href="#进入阻塞状态" class="headerlink" title="进入阻塞状态"></a>进入阻塞状态</h4><p>一个任务进入阻塞状态，可能有如下原因：</p>
<ul>
<li>1.通过调用sleep(milliseconds)使任务进入休眠状态，在这种情况下，任务在指定的时间内不会运行。</li>
<li>2.通过调用wait()使线程挂起。直到线程得到了notify()或notifyAll()消息，线程才会进入就绪状态。</li>
<li>3.任务在等待某个输入/输出完成。</li>
<li>4.任务在试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。</li>
</ul>
<p>早版本的java中使用suspend()和resume()来阻塞和唤醒线程，现代java中这些方法被废弃（因为可能导致死锁）。stop()方法也被废止了，因为它不释放线程获得的锁，并且如果线程处于不一致状态，其他任务可以在这种状态下浏览并修改它们。</p>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>Thread类包含interrupt()方法，可以终止被阻塞的任务，这个方法将设置线程的中断状态。如果一个线程已经被阻塞，或者试图执行一个阻塞操作，那么设置这个线程的中断状态将抛出InterruptedException。当抛出该异常或者该任务调用Thread.interrupted()时，中断状态将被复位。Thread.interrupted()提供了离开run()循环而不抛出异常的第二种方式。</p>
<p>新的concurrent类库在避免对Thread对象的直接操作，转而尽量通过Executor来执行所有操作。如果在Executor上调用shutdownNow(),那么它将发送一个interrupt()调用给它启动的所有线程。</p>
<p>有时希望只中断某个单一任务。如果使用Executor，通过调用submit()而不是executor()来启动任务，就可以持有该任务的上下文。submit()将返回一个泛型Future&lt;?&gt;,其中有一个未修饰的参数。持有这个Future的关键是在于可以在其上调用cancel()，并因此可以使用它来中断某个特定任务。如果将true传递给cancel(),那么它就会拥有在该线程上调用interrupt()以停止这个线程的权限。cancel()是一种中断由Executor启动的单个线程的方式。</p>
<p>Future<v>接口的方法：</v></p>
<p>boolean cancel(boolean mayInterruptIfRunning)</p>
<p>试图取消对此任务的执行。如果任务已完成、或已取消，或者由于某些其他原因而无法取消，则此尝试将失败。当调用 cancel 时，如果调用成功，而此任务尚未启动，则此任务将永不运行。如果任务已经启动，则 mayInterruptIfRunning参数确定是否应该以试图停止任务的方式来中断执行此任务的线程。</p>
<p>此方法返回后，对 isDone() 的后续调用将始终返回 true。如果此方法返回 true，则对 isCancelled() 的后续调用将始终返回 true。 </p>
<p>参数：</p>
<p>mayInterruptIfRunning - 如果应该中断执行此任务的线程，则为 true；否则允许正在运行的任务运行完成 </p>
<p>返回：</p>
<p>如果无法取消任务，则返回 false，这通常是由于它已经正常完成；否则返回 true</p>
<hr>
<p>boolean isCancelled()如果在任务正常完成前将其取消，则返回 true。 </p>
<p>返回：</p>
<p>如果任务完成前将其取消，则返回 true</p>
<hr>
<p>boolean isDone()</p>
<p>如果任务已完成，则返回 true。可能由于正常终止、异常或取消而完成，在所有这些情况中，此方法都将返回 true。 </p>
<p>返回：</p>
<p>如果任务已完成，则返回 true</p>
<hr>
<p>V get() throws InterruptedException,ExecutionException</p>
<p>如有必要，等待计算完成，然后获取其结果。 </p>
<p>返回：</p>
<p>计算的结果 </p>
<p>抛出： </p>
<p>CancellationException - 如果计算被取消<br>ExecutionException - 如果计算抛出异常<br>InterruptedException - 如果当前的线程在等待时被中断</p>
<p>sleep()是可中断的阻塞，而I/O和在synchronized块上等待是不可中断的阻塞。无论是I/O还是尝试调用synchronized方法，都不需要任何InterruptedException处理器。<br>也就是说，可以中断对sleep()的调用，而不能中断正在试图获取synchronized锁或者试图执行I/O操作的线程。关闭任务在其上发生阻塞的底层资源，可以解除I/O阻塞。</p>
<p>被阻塞的nio通道会自动的响应中断。</p>
<p>一个任务应该能够调用在同一个对象中的其他的synchronized方法，而这个任务已经持有锁了。</p>
<h4 id="检查中断"><a href="#检查中断" class="headerlink" title="检查中断"></a>检查中断</h4><hr>
<div><br><font color="red"><strong><br>当我们调用t.interrput()的时候，线程t的中断状态(interrupted status)  会被置位,即设置为true。我们可以通过Thread.currentThread().interrupted()    来检查这个布尔型的中断状态。<br><br><br>在Core Java中有这样一句话：”没有任何语言方面的需求要求一个被中断的程序应该终止。中断一个线程只是为了引起该线程的注意，被中断线程可以决定如何应对中断 “。<br><br><br>这说明我们调用t.interrupt()之后，并不能中断线程，只有线程内部检查了中断状态并作出反应才行。<br><br>但是当t被阻塞的时候，比如被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞时，调用它的interrput()方法，会产生一个InterruptedException异常。<br></strong><br></font><br></div>

<hr>
<p>检查中断的常用写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Interrupted的经典使用代码  </span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </div><div class="line">    <span class="keyword">try</span>&#123;  </div><div class="line">        ....  </div><div class="line">         <span class="keyword">while</span>(!Thread.currentThread().interrupted()&amp;&amp; more work to <span class="keyword">do</span>)&#123;  </div><div class="line">            <span class="comment">// do more work;  </span></div><div class="line">        &#125;  </div><div class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;  </div><div class="line">        <span class="comment">// thread was interrupted during sleep or wait  </span></div><div class="line">    &#125;  <span class="keyword">finally</span>&#123;  </div><div class="line">               <span class="comment">// cleanup, if required  </span></div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意interrupted()方法和isInterruputed()方法的区别：</p>
<p><strong>interrupted()会改变线程的中断状态，isInterrupted()不会改变线程的中断状态。</strong></p>
<p>public static boolean interrupted()</p>
<p>测试当前线程是否已经中断。线程的中断状态 由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回 false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。<br>线程中断被忽略，因为在中断时不处于活动状态的线程将由此返回 false 的方法反映出来。 </p>
<p>返回：</p>
<p>如果当前线程已经中断，则返回 true；否则返回 false。</p>
<hr>
<p>public boolean isInterrupted()</p>
<p>测试线程是否已经中断。线程的中断状态 不受该方法的影响。<br>线程中断被忽略，因为在中断时不处于活动状态的线程将由此返回 false 的方法反映出来。 </p>
<p>返回：</p>
<p>如果该线程已经中断，则返回 true；否则返回 false。</p>
<h3 id="4-线程之间的协作"><a href="#4-线程之间的协作" class="headerlink" title="4.线程之间的协作"></a>4.线程之间的协作</h3><p>第二节解决的是线程同步问题，即使用锁来同步两个任务的行为，从而使一个任务不会干涉另一个任务的资源。</p>
<p>下面要解决线程之间的协作，已使得多个任务可以一起工作去解决某个问题。</p>
<h4 id="4-1-wain-和notifyAll"><a href="#4-1-wain-和notifyAll" class="headerlink" title="4.1 wain()和notifyAll()"></a>4.1 wain()和notifyAll()</h4><p>wait()会在等待外部世界产生变化的时候将任务挂起，并且只有在notify()或notifyAll()发生时，这个任务才会被唤醒并去检查所产生的变化。</p>
<p>调用sleep()的时候锁并没有被释放，调用yield()也是如此。当一个任务在方法里遇到了对wait()的调用时，线程的执行被挂起，对象的锁被释放。</p>
<p>还有一点要注意的是：wait()是Object对象的方法，而sleep()是Thread对象的方法。</p>
<p>有两种形式的wait().</p>
<p>第一个版本是以毫秒数为参数，含义与sleep()方法里的参数相同，都是“在此期间暂停”。但是与sleep()不同的是，对于wait()而言：</p>
<p>（1）在wait()期间对象锁是释放的</p>
<p>（2）可以通过notify()、notifyAll()，或者时间到期，从wait()中恢复执行。</p>
<p>第二种，也是更常用的形式的wait()不接受任何参数，这种wait()将无限等待下去，直到线程接收到notify()或notifyAll()消息。</p>
<p>wait()、notifyAll()、notify()这些方法都是基类Object的一部分。可以把wait()放进如何同步控制方法里，而不用考虑这个类是继承自Thread还是实现了Runnable接口。而且，只能在同步控制方法或同步控制块里调用wait、notify、notifyAll（sleep()不用操作锁，所以可以在非同步控制方法里使用。）</p>
<p>如果在非同步控制方法里调用这些方法，程序能编译通过，但是运行的时候，将得到IllegalmonitorStateException异常，并有一些消息，比如“当前线程不是拥有者”。意思是，调用wait、notify、notifyAll的任务在调用这些方法前必须拥有对象的锁。</p>
<h4 id="4-2-notify-与notifyAll"><a href="#4-2-notify-与notifyAll" class="headerlink" title="4.2 notify()与notifyAll()"></a>4.2 notify()与notifyAll()</h4><p>使用notify()而不是notifyAll()是一种优化。使用notify()时，在众多等待同一个锁的任务中只有一个会被唤醒。</p>
<p>当notifyAll()因某个特定锁而被调用时，只有等待这个锁的任务才会被唤醒。</p>
<h4 id="4-3-生产者与消费者"><a href="#4-3-生产者与消费者" class="headerlink" title="4.3 生产者与消费者"></a>4.3 生产者与消费者</h4><p>使用互斥并允许任务挂起的基本类是Condition，可以通过在Condition上调用await()来挂起一个任务。当外部条件发生变化，意味着某个任务应该继续执行时，可以通过调用signal()来通知这个任务，从而唤醒一个任务，或者调用signalAll()来唤醒所有在这个Condition上被其自身挂起的任务（与使用notifyAll()相比，signalAll()是更安全的方式）。</p>
<p>使用方式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> waxOn = <span class="keyword">false</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waxed</span><span class="params">()</span></span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            waxOn = <span class="keyword">true</span>;</div><div class="line">            condition.signalAll();</div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitForWaxing</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="keyword">while</span>(waxOn == <span class="keyword">false</span>)</div><div class="line">                condition.await();</div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Lock和Condition对象只有在更加困难的多线程问题中才是必需的。</p>
<h4 id="4-4-生产者-消费者队列"><a href="#4-4-生产者-消费者队列" class="headerlink" title="4.4 生产者-消费者队列"></a>4.4 生产者-消费者队列</h4><p>同步队列在任何时刻只能允许一个任务插入或移除元素。在java.util.concurrent.BlockingQueue接口中提供了这个队列，这个接口有大量的标准实现。LinkedBlockingQueue是无界队列，ArrayBlockingQueue具有固定尺寸，在它被阻塞之前，向其中放置有限数量的元素。</p>
<p>如果消费者试图从队列中获取对象，而该对象为空，那么这些队列还可以挂起消费者任务，并且当有更多的元素可用时恢复消费者任务。</p>
<p>以下是基于典型的生产者-使用者场景的一个用例。注意，BlockingQueue 可以安全地与多个生产者和多个使用者一起使用。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue queue;</div><div class="line">    Producer(BlockingQueue q) &#123; queue = q; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123; queue.put(produce()); &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function">Object <span class="title">produce</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">&#125;                                   </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue queue;</div><div class="line">    Consumer(BlockingQueue q) &#123; queue = q; &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span>(<span class="keyword">true</span>) &#123; consume(queue.take()); &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">(Object x)</span> </span>&#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Setup</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">            BlockingQueue q = <span class="keyword">new</span> SomeQueueImplementation();</div><div class="line">        Producer p = <span class="keyword">new</span> Producer(q);</div><div class="line">        Consumer c1 = <span class="keyword">new</span> Consumer(q);</div><div class="line">        Consumer c2 = <span class="keyword">new</span> Consumer(q);</div><div class="line">        <span class="keyword">new</span> Thread(p).start();</div><div class="line">        <span class="keyword">new</span> Thread(c1).start();</div><div class="line">        <span class="keyword">new</span> Thread(c2).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-5-任务间使用管道进行输入-输出"><a href="#4-5-任务间使用管道进行输入-输出" class="headerlink" title="4.5 任务间使用管道进行输入/输出"></a>4.5 任务间使用管道进行输入/输出</h4><p>通过输入/输出在线程间进行通信通常很有用。以“管道”的形式对线程间的输入/输出提供了支持。PipedWriter(允许任务向管道写)和PipedReader(允许不同任务从同一个管道中读取)。管道基本上是一个阻塞队列。</p>
<p>PipedReader与普通I/O之间最重要的差异——PipedReader是可中断的。</p>
<h3 id="5-死锁"><a href="#5-死锁" class="headerlink" title="5.死锁"></a>5.死锁</h3><p><strong>死锁</strong>：某个任务在等待另一个任务，而后者又在等待别的任务，这样一直下去，直到这个链条上的任务又在等待第一个任务释放锁。这些任务之间响度等待，没有哪一个线程能继续。</p>
<p>产生死锁的四个必要条件：</p>
<p>（1） 互斥条件：一个资源每次只能被一个进程使用。</p>
<p>（2） 请求保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p>
<p>（3） 不可抢占条件:进程已获得的资源，在末使用完之前，不能强行剥夺。</p>
<p>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<h3 id="6-新类库中的构件"><a href="#6-新类库中的构件" class="headerlink" title="6.新类库中的构件"></a>6.新类库中的构件</h3><h4 id="6-1-CountDownLatch"><a href="#6-1-CountDownLatch" class="headerlink" title="6.1 CountDownLatch"></a>6.1 CountDownLatch</h4><p>一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。 </p>
<p>用给定的计数 初始化 CountDownLatch。由于调用了 countDown() 方法，所以在当前计数到达零之前，await 方法会一直受阻塞。之后，会释放所有等待的线程，await 的所有后续调用都将立即返回。这种现象只出现一次——计数无法被重置。如果需要重置计数，请考虑使用 CyclicBarrier。 </p>
<p>CountDownLatch 是一个通用同步工具，它有很多用途。</p>
<ul>
<li>将计数 1 初始化的 CountDownLatch 用作一个简单的开/关锁存器，或入口：在通过调用 countDown() 的线程打开入口前，所有调用 await 的线程都一直在入口处等待。</li>
<li>用 N 初始化的 CountDownLatch 可以使一个线程在 N 个线程完成某项操作之前一直等待，或者使其在某项操作完成 N 次之前一直等待。 </li>
</ul>
<p>CountDownLatch 的一个有用特性是，它不要求调用 countDown 方法的线程等到计数到达零时才继续，而在所有线程都能通过之前，它只是阻止任何线程继续通过一个 await。 </p>
<p>示例用法： 下面给出了两个类，其中一组 worker 线程使用了两个倒计数锁存器： </p>
<p>第一个类是一个启动信号，在 driver 为继续执行 worker 做好准备之前，它会阻止所有的 worker 继续执行。<br>第二个类是一个完成信号，它允许 driver 在完成所有 worker 之前一直等待。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123; <span class="comment">// ...</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</div><div class="line"></div><div class="line">        doSomethingElse();            <span class="comment">// don't let run yet</span></div><div class="line">        startSignal.countDown();      <span class="comment">// let all threads proceed</span></div><div class="line">        doSomethingElse();</div><div class="line">        doneSignal.await();           <span class="comment">// wait for all to finish</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</div><div class="line">    Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</div><div class="line">        <span class="keyword">this</span>.startSignal = startSignal;</div><div class="line">        <span class="keyword">this</span>.doneSignal = doneSignal;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            startSignal.await();</div><div class="line">            doWork();</div><div class="line">            doneSignal.countDown();</div><div class="line">        <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 另一种典型用法是，将一个问题分成 N 个部分，用执行每个部分并让锁存器倒计数的 Runnable 来描述每个部分，然后将所有 Runnable 加入到 Executor 队列。当所有的子部分完成后，协调线程就能够通过 await。（当线程必须用这种方法反复倒计数时，可改为使用 CyclicBarrier。） </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver2</span> </span>&#123; <span class="comment">// ...</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</div><div class="line">        Executor e = ...</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></div><div class="line">            e.execute(<span class="keyword">new</span> WorkerRunnable(doneSignal, i));</div><div class="line"></div><div class="line">        doneSignal.await();           <span class="comment">// wait for all to finish</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</div><div class="line">    WorkerRunnable(CountDownLatch doneSignal, <span class="keyword">int</span> i) &#123;</div><div class="line">        <span class="keyword">this</span>.doneSignal = doneSignal;</div><div class="line">        <span class="keyword">this</span>.i = i;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            doWork(i);</div><div class="line">            doneSignal.countDown();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内存一致性效果：线程中调用 countDown() 之前的操作 happen-before 紧跟在从另一个线程中对应 await() 成功返回的操作。 </p>
<h4 id="6-2-CyclicBarrier"><a href="#6-2-CyclicBarrier" class="headerlink" title="6.2 CyclicBarrier"></a>6.2 CyclicBarrier</h4><p>一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点 (common barrier point)。在涉及一组固定大小的线程的程序中，这些线程必须不时地互相等待，此时 CyclicBarrier 很有用。因为该 barrier 在释放等待线程后可以重用，所以称它为循环 的 barrier。 </p>
<p>CyclicBarrier 支持一个可选的 Runnable 命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。若在继续所有参与线程之前更新共享状态，此屏障操作 很有用。 </p>
<p>示例用法：下面是一个在并行分解设计中使用 barrier 的例子： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solver</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">float</span>[][] data;</div><div class="line">    <span class="keyword">final</span> CyclicBarrier barrier;</div><div class="line">            </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> myRow;</div><div class="line">        Worker(<span class="keyword">int</span> row) &#123; myRow = row; &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span> (!done()) &#123;</div><div class="line">                processRow(myRow);</div><div class="line"></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    barrier.await(); </div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; </div><div class="line">                    <span class="keyword">return</span>; </div><div class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException ex) &#123; </div><div class="line">                    <span class="keyword">return</span>; </div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solver</span><span class="params">(<span class="keyword">float</span>[][] matrix)</span> </span>&#123;</div><div class="line">        data = matrix;</div><div class="line">        N = matrix.length;</div><div class="line">        barrier = <span class="keyword">new</span> CyclicBarrier(N, <span class="keyword">new</span> Runnable() &#123;</div><div class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; </div><div class="line">                                        mergeRows(...); </div><div class="line">                                        &#125;</div><div class="line">                                    &#125;);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) </div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(i)).start();</div><div class="line"></div><div class="line">        waitUntilDone();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，每个 worker 线程处理矩阵的一行，在处理完所有的行之前，该线程将一直在屏障处等待。处理完所有的行之后，将执行所提供的 Runnable 屏障操作，并合并这些行。如果合并者确定已经找到了一个解决方案，那么 done() 将返回 true，所有的 worker 线程都将终止。 </p>
<p>如果屏障操作在执行时不依赖于正挂起的线程，则线程组中的任何线程在获得释放时都能执行该操作。为方便此操作，每次调用 await() 都将返回能到达屏障处的线程的索引。然后，您可以选择哪个线程应该执行屏障操作，例如： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (barrier.await() == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// log the completion of this iteration</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于失败的同步尝试，CyclicBarrier 使用了一种要么全部要么全不 (all-or-none) 的破坏模式：如果因为中断、失败或者超时等原因，导致线程过早地离开了屏障点，那么在该屏障点等待的其他所有线程也将通过 BrokenBarrierException（如果它们几乎同时被中断，则用 InterruptedException）以反常的方式离开。 </p>
<p>CountDownLatch和CyclicBarrier的区别</p>
<p>javadoc里面的描述是这样的。</p>
<blockquote>
<p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p>
<p>CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.</p>
</blockquote>
<p>CountDownLatch : 一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行。<br>CyclicBarrier        : N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。</p>
<p>这样应该就清楚一点了，对于CountDownLatch来说，重点是那个“一个线程”, 是它在等待， 而另外那 N 的线程在把“某个事情”做完之后可以继续等待，可以终止。</p>
<p>而对于CyclicBarrier来说，重点是那N个线程，他们之间任何一个没有完成，所有的线程都必须等待。</p>
<p>有一篇博客介绍CountDownLatch和CyclicBarrier的实现原理的，有时间再研究一下</p>
<p><a href="http://blog.csdn.net/pun_c/article/details/37658841?utm_source=tuicool" target="_blank" rel="external">CountDownLatch &amp; CyclicBarrier源码实现解析</a></p>
<h4 id="6-3-DelayQueue"><a href="#6-3-DelayQueue" class="headerlink" title="6.3 DelayQueue"></a>6.3 DelayQueue</h4><p>DelayQueue<e extends="" delayed=""></e></p>
<p>这是一个无界阻塞队列（BlockingQueue），用于放置实现了Delayed接口的 对象，只有在延迟期满时才能从中提取元素。该队列的头部 是延迟期满后保存时间最长的对象。如果延迟都还没有期满，则队列没有头部，并且 poll 将返回 null。当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于等于 0 的值时，将发生到期。即使无法使用 take 或 poll 移除未到期的元素，也不会将这些元素作为正常元素对待。例如，size 方法同时返回到期和未到期元素的计数。此队列不允许使用 null 元素。 </p>
<h4 id="6-4-PriorityBlockingQueue"><a href="#6-4-PriorityBlockingQueue" class="headerlink" title="6.4 PriorityBlockingQueue"></a>6.4 PriorityBlockingQueue</h4><h4 id="6-5-ScheduledExecutor"><a href="#6-5-ScheduledExecutor" class="headerlink" title="6.5 ScheduledExecutor"></a>6.5 ScheduledExecutor</h4><p>public class ScheduledThreadPoolExecutor<br>extends ThreadPoolExecutor<br>implements ScheduledExecutorService</p>
<p>是一个ThreadPoolExecutor，它可另行安排在给定的延迟后运行命令，或者定期执行命令。需要多个辅助线程时，或者要求 ThreadPoolExecutor 具有额外的灵活性或功能时，此类要优于 Timer。 </p>
<p>一旦启用已延迟的任务就执行它，但是有关何时启用，启用后何时执行则没有任何实时保证。按照提交的先进先出 (FIFO) 顺序来启用那些被安排在同一执行时间的任务。 </p>
<p>虽然此类继承自 ThreadPoolExecutor，但是几个继承的调整方法对此类并无作用。特别是，因为它作为一个使用 corePoolSize 线程和一个无界队列的固定大小的池，所以调整 maximumPoolSize 没有什么效果。 </p>
<h4 id="6-6-Semaphore"><a href="#6-6-Semaphore" class="headerlink" title="6.6 Semaphore"></a>6.6 Semaphore</h4><p>public class Semaphoreextends Objectimplements Serializable一个计数信号量。从概念上讲，信号量维护了一个许可集。如有必要，在许可可用前会阻塞每一个 acquire()，然后再获取该许可。每个 release() 添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore 只对可用许可的号码进行计数，并采取相应的行动。 </p>
<p>Semaphore 通常用于限制可以访问某些资源（物理或逻辑的）的线程数目。例如，下面的类使用信号量控制对内容池的访问： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILABLE = <span class="number">100</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore available = <span class="keyword">new</span> Semaphore(MAX_AVAILABLE, <span class="keyword">true</span>); </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        available.acquire();</div><div class="line">        <span class="keyword">return</span> getNextAvailableItem();</div><div class="line">    &#125;   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putItem</span><span class="params">(Object x)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (markAsUnused(x))</div><div class="line">            available.release();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Not a particularly efficient data structure; just for demo</span></div><div class="line"></div><div class="line">    <span class="keyword">protected</span> Object[] items = ... whatever kinds of items being managed</div><div class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILABLE];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">getNextAvailableItem</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (!used[i]) &#123;</div><div class="line">                used[i] = <span class="keyword">true</span>;</div><div class="line">                <span class="keyword">return</span> items[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// not reached</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(Object item)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</div><div class="line">            <span class="keyword">if</span> (item == items[i]) &#123;</div><div class="line">                <span class="keyword">if</span> (used[i]) &#123;</div><div class="line">                used[i] = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获得一项前，每个线程必须从信号量获取许可，从而保证可以使用该项。该线程结束后，将项返回到池中并将许可返回到该信号量，从而允许其他线程获取该项。注意，调用 acquire() 时无法保持同步锁，因为这会阻止将项返回到池中。信号量封装所需的同步，以限制对池的访问，这同维持该池本身一致性所需的同步是分开的。 </p>
<p>将信号量初始化为 1，使得它在使用时最多只有一个可用的许可，从而可用作一个相互排斥的锁。这通常也称为二进制信号量，因为它只能有两种状态：一个可用的许可，或零个可用的许可。按此方式使用时，二进制信号量具有某种属性（与很多 Lock 实现不同），即可以由线程释放“锁”，而不是由所有者（因为信号量没有所有权的概念）。在某些专门的上下文（如死锁恢复）中这会很有用。 </p>
<p>此类的构造方法可选地接受一个公平 参数。当设置为 false 时，此类不对线程获取许可的顺序做任何保证。特别地，闯入 是允许的，也就是说可以在已经等待的线程前为调用 acquire() 的线程分配一个许可，从逻辑上说，就是新线程将自己置于等待线程队列的头部。当公平设置为 true 时，信号量保证对于任何调用获取方法的线程而言，都按照处理它们调用这些方法的顺序（即先进先出；FIFO）来选择线程、获得许可。注意，FIFO 排序必然应用到这些方法内的指定内部执行点。所以，可能某个线程先于另一个线程调用了 acquire，但是却在该线程之后到达排序点，并且从方法返回时也类似。还要注意，非同步的 tryAcquire 方法不使用公平设置，而是使用任意可用的许可。 </p>
<p>通常，应该将用于控制资源访问的信号量初始化为公平的，以确保所有线程都可访问资源。为其他的种类的同步控制使用信号量时，非公平排序的吞吐量优势通常要比公平考虑更为重要。 </p>
<p>此类还提供便捷的方法来同时 acquire 和释放多个许可。小心，在未将公平设置为 true 时使用这些方法会增加不确定延期的风险。 </p>
<h4 id="6-6-Exchanger"><a href="#6-6-Exchanger" class="headerlink" title="6.6 Exchanger"></a>6.6 Exchanger</h4><p>public class Exchanger<v> extends Object</v></p>
<p>可以在对中对元素进行配对和交换的线程的同步点。每个线程将条目上的某个方法呈现给 exchange 方法，与伙伴线程进行匹配，并且在返回时接收其伙伴的对象。Exchanger 可能被视为 SynchronousQueue 的双向形式。Exchanger 可能在应用程序（比如遗传算法和管道设计）中很有用。 </p>
<p>用法示例：以下是重点介绍的一个类，该类使用 Exchanger 在线程间交换缓冲区，因此，在需要时，填充缓冲区的线程获取一个新腾空的缓冲区，并将填满的缓冲区传递给腾空缓冲区的线程。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FillAndEmpty</span> </span>&#123;</div><div class="line">    Exchanger&lt;DataBuffer&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;DataBuffer&gt;();</div><div class="line">    DataBuffer initialEmptyBuffer = ... a made-up type</div><div class="line">    DataBuffer initialFullBuffer = ...</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FillingLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            DataBuffer currentBuffer = initialEmptyBuffer;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span> (currentBuffer != <span class="keyword">null</span>) &#123;</div><div class="line">                    addToBuffer(currentBuffer);</div><div class="line">                    <span class="keyword">if</span> (currentBuffer.isFull())</div><div class="line">                        currentBuffer = exchanger.exchange(currentBuffer);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ... &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EmptyingLoop</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            DataBuffer currentBuffer = initialFullBuffer;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span> (currentBuffer != <span class="keyword">null</span>) &#123;</div><div class="line">                takeFromBuffer(currentBuffer);</div><div class="line">                <span class="keyword">if</span> (currentBuffer.isEmpty())</div><div class="line">                    currentBuffer = exchanger.exchange(currentBuffer);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> FillingLoop()).start();</div><div class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> EmptyingLoop()).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="7、性能调优"><a href="#7、性能调优" class="headerlink" title="7、性能调优"></a>7、性能调优</h3><h4 id="7-1-比较各种互斥技术"><a href="#7-1-比较各种互斥技术" class="headerlink" title="7.1 比较各种互斥技术"></a>7.1 比较各种互斥技术</h4><p>使用Lock通常会比使用synchronized要高效很多，而且synchronized的开销看起来变化范围很大，而Lock相对比较一致。</p>
<p>这是否意味着不使用synchronized呢？有两个因素要考虑：</p>
<p>首先，实际中，被互斥的部分比较大，因此在这些方法体中花费的时间的百分比可能会明显大于进入和退出互斥的开销，这样也就湮灭了提高互斥速度带来的好处。当在进行性能调优时，可以尝试各种不同的方法并观察它们造成的影响。</p>
<p>其次，synchronized关键词的代码的可读性要比lock-try/finally-unlock方法的代码的可读性高。因此，以synchronized关键字入手，只有在性能调优时才替换为Lock对象这种做法，比较具有实际意义。</p>
<p>Atomic对象只有在非常简单的情况下才有用，这些情况包括只有一个要被修改的Atomic对象，并且这个对象对立于其他所有的对象。更安全的做法是：以更加传统的互斥方式入手，只有在性能方面的需求能够明确指示时，才替换Atomic。</p>
<h4 id="7-2-免锁容器"><a href="#7-2-免锁容器" class="headerlink" title="7.2 免锁容器"></a>7.2 免锁容器</h4><p>免锁容器的通用策略是：对容器的修改可以与读取操作同时发生，只要读取者只能看到完成修改的结果即可。修改时在容器数据结构的某个部分的一个单独的副本上执行的，并且这个副本在修改过程中是不可视的。只有当修改完成时，被修改的结构才会自动的与主数据结构进行交换，之后读取者就可以看到这个修改了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://vernlium.github.io/2015/06/30/Markdown基础语法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Anan Zhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="AnanZhang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/06/30/Markdown基础语法/" itemprop="url">Markdown基础语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-06-30T21:13:12+08:00">
                2015-06-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="基本符号"><a href="#基本符号" class="headerlink" title="基本符号"></a>基本符号</h3><ul>
<li>*,-,+ 3个符号效果都一样，这3个符号被称为 Markdown符号</li>
<li>空白行表示另起一个段落</li>
<li>`是表示inline代码，tab是用来标记 代码段，分别对应html的code，pre标签</li>
</ul>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><ul>
<li>单一段落( <code>&lt;p&gt;</code>) 用一个空白行</li>
<li>连续两个空格 会变成一个 <br></li>
<li>连续3个符号，然后是空行，表示 hr横线</li>
</ul>
<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><ul>
<li>生成h1–h6,在文字前面加上 1–6个# 来实现</li>
<li>文字加粗是通过 文字左右各两个符号</li>
</ul>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul>
<li>在第一行加上 “&gt;”和一个空格，表示代码引用，还可以嵌套</li>
</ul>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>这个是markdown文件的主要表示方式，主题要点化</p>
<ul>
<li>使用*,+,-加上一个空格来表示</li>
<li>可以支持嵌套,示例如下：</li>
<li>有序列表用 数字+英文点+空格来表示</li>
<li>列表内容很长，不需要手工输入换行符，css控制段落的宽度，会自动的缩放的</li>
</ul>
<p>列表嵌套示例如下：</p>
<pre><code>- 外层列表项目
    + 内层列表项目
    + 内层无序列表项目
    + 内层列表项目
- 外层列表项目
</code></pre><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul>
<li>直接写 <a href="url" title="可选的title">锚文本</a></li>
<li>引用 先定义 [ref_name]:url，然后在需要写入url的地方， 这样使用[锚文本][ref_name]，通常的ref_name一般用数字表示，这样显得专业</li>
<li>简写url：用尖括号包裹url </li>
<li>这样生成的url锚文本就是url本身</li>
</ul>
<h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><ul>
<li>一行表示: <code>![alt_text](url &quot;可选的title&quot;)</code></li>
<li>引用表示法: ![alt_text][id],预先定义 [id]:url “可选title”</li>
<li>直接使用<img>标签，这样可以指定图片的大小尺寸</li>
</ul>
<h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><ul>
<li>用\来转义，表示文本中的markdown符号</li>
<li>可以在文本种直接使用html标签，但是要注意在使用的时候，前后加上空行</li>
<li>文本前后各加一个符号，表示斜体</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Anan Zhang" />
          <p class="site-author-name" itemprop="name">Anan Zhang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/vernlium" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/ananzhang" target="_blank" title="ZhiHu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      ZhiHu
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Anan Zhang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
