<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="本周课程主要讲解了神经网络中的优化的一些方法，要点：  Train/Dev/Test（训练/开发/测试数据集） 偏差和方差 欠拟合和过拟合 Regularization正则化 Dropout随机失活 Normalizing归一化 梯度消失和梯度爆炸 梯度检查  本周课程将从实际应用的角度介绍深度学习，上周课程已经学会了如何实现一个神经网络，本周将学习，实际应用中如何使神经网络高效工作。本周将学习在">
<meta property="og:type" content="article">
<meta property="og:title" content="coursera-deeplearning-ai-c2-week1">
<meta property="og:url" content="://vernlium.github.io/2018/07/05/coursera-deeplearning-ai-c2-week1/index.html">
<meta property="og:site_name" content="Vernlium">
<meta property="og:description" content="本周课程主要讲解了神经网络中的优化的一些方法，要点：  Train/Dev/Test（训练/开发/测试数据集） 偏差和方差 欠拟合和过拟合 Regularization正则化 Dropout随机失活 Normalizing归一化 梯度消失和梯度爆炸 梯度检查  本周课程将从实际应用的角度介绍深度学习，上周课程已经学会了如何实现一个神经网络，本周将学习，实际应用中如何使神经网络高效工作。本周将学习在">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="/2018/07/05/coursera-deeplearning-ai-c2-week1/bias_and_variance.jpg">
<meta property="og:image" content="/2018/07/05/coursera-deeplearning-ai-c2-week1/basic_recipe_for_machine_learning.jpg">
<meta property="og:image" content="/2018/07/05/coursera-deeplearning-ai-c2-week1/bias_and_variance.jpg">
<meta property="og:image" content="/2018/07/05/coursera-deeplearning-ai-c2-week1/intuitive_understanding_of_regularizing.jpg">
<meta property="og:image" content="/2018/07/05/coursera-deeplearning-ai-c2-week1/data_augmentation.jpg">
<meta property="og:image" content="/2018/07/05/coursera-deeplearning-ai-c2-week1/early_stoping.jpg">
<meta property="og:image" content="/2018/07/05/coursera-deeplearning-ai-c2-week1/normalizing_training_sets.jpg">
<meta property="og:image" content="/2018/07/05/coursera-deeplearning-ai-c2-week1/why_normalize_inputs.jpg">
<meta property="og:image" content="/2018/07/05/coursera-deeplearning-ai-c2-week1/l_layer_network.jpg">
<meta property="og:image" content="/2018/07/05/coursera-deeplearning-ai-c2-week1/single_neuron_example.jpg">
<meta property="og:image" content="/2018/07/05/coursera-deeplearning-ai-c2-week1/1Dgrad_kiank.png">
<meta property="og:image" content="/2018/07/05/coursera-deeplearning-ai-c2-week1/NDgrad_kiank.png">
<meta property="og:image" content="/2018/07/05/coursera-deeplearning-ai-c2-week1/dictionary_to_vector.png">
<meta property="og:updated_time" content="2018-08-12T13:28:37.301Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="coursera-deeplearning-ai-c2-week1">
<meta name="twitter:description" content="本周课程主要讲解了神经网络中的优化的一些方法，要点：  Train/Dev/Test（训练/开发/测试数据集） 偏差和方差 欠拟合和过拟合 Regularization正则化 Dropout随机失活 Normalizing归一化 梯度消失和梯度爆炸 梯度检查  本周课程将从实际应用的角度介绍深度学习，上周课程已经学会了如何实现一个神经网络，本周将学习，实际应用中如何使神经网络高效工作。本周将学习在">
<meta name="twitter:image" content="/2018/07/05/coursera-deeplearning-ai-c2-week1/bias_and_variance.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="://vernlium.github.io/2018/07/05/coursera-deeplearning-ai-c2-week1/"/>





  <title>coursera-deeplearning-ai-c2-week1 | Vernlium</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vernlium</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Keep codeing and thinking!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="://vernlium.github.io/2018/07/05/coursera-deeplearning-ai-c2-week1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张阿楠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/wukong.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vernlium">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">coursera-deeplearning-ai-c2-week1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-05T07:15:57+08:00">
                2018-07-05
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/05/coursera-deeplearning-ai-c2-week1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/07/05/coursera-deeplearning-ai-c2-week1/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本周课程主要讲解了神经网络中的优化的一些方法，要点：</p>
<ul>
<li>Train/Dev/Test（训练/开发/测试数据集）</li>
<li>偏差和方差</li>
<li>欠拟合和过拟合</li>
<li>Regularization正则化</li>
<li>Dropout随机失活</li>
<li>Normalizing归一化</li>
<li>梯度消失和梯度爆炸</li>
<li>梯度检查</li>
</ul>
<p>本周课程将从实际应用的角度介绍深度学习，上周课程已经学会了如何实现一个神经网络，本周将学习，实际应用中如何使神经网络高效工作。本周将学习在实际应用中如何使神经网络高效工作。这些方法包括超参数调整，数据准备，再到如何确保优化算法运行得足够快，以使得学习算法能在合理的时间内完成学习任务。</p>
<p><strong>学习目标</strong></p>
<ul>
<li>Recall that different types of initializations lead to different results</li>
<li>Recognize the importance of initialization in complex neural networks.</li>
<li>Recognize the difference between train/dev/test sets</li>
<li>Diagnose the bias and variance issues in your model</li>
<li>Learn when and how to use regularization methods such as dropout or L2 regularization.</li>
<li>Understand experimental issues in deep learning such as Vanishing or Exploding gradients and learn how to deal with them</li>
<li>Use gradient checking to verify the correctness of your backpropagation implementation</li>
</ul>
<h2 id="课程笔记"><a href="#课程笔记" class="headerlink" title="课程笔记"></a>课程笔记</h2><h3 id="Setting-up-your-Machine-Learning-Application"><a href="#Setting-up-your-Machine-Learning-Application" class="headerlink" title="Setting up your Machine Learning Application"></a>Setting up your Machine Learning Application</h3><h4 id="Train-Dev-Test-sets"><a href="#Train-Dev-Test-sets" class="headerlink" title="Train / Dev / Test sets"></a>Train / Dev / Test sets</h4><p>数据集分为<strong>训练集</strong>、<strong>开发集</strong>和<strong>测试集</strong>。</p>
<p>假设这是你的训练数据，把它画成一个大矩形，那么传统的做法是你可能会从所有数据中，取出一部分用作训练集，然后再留出一部分作为hold-out交叉验证集（hold-out cross validation set）。这个数据集有时也称为开发集，为了简洁，把它称为”dev set”。再接下来从最后取出一部分用作测试集。</p>
<p>整个工作流程：</p>
<ul>
<li>首先不停地用<strong>训练集</strong>来训练你的算法</li>
<li>然后用你的<strong>开发集</strong>或说hold-out交叉验证集来测试，许多不同的模型里哪一个在开发集上效果最好</li>
<li>最后评估最终的训练结果，可以用<strong>测试集</strong>对结果中最好的模型进行评估，这样以使得评估算法性能时不引入偏差 </li>
</ul>
<p>在上一个时代的机器学习中，通常的分割法是，训练集和测试集分别占整体数据70%和30%。如果你明确地设定了开发集，那比例可能是60/20/20%，也就是测试集占60%，开发集20%，测试集20%，</p>
<p>数年以前这个比例被广泛认为是，机器学习中的最佳方法，如果一共只有100个样本，也许1000个样本，甚至到1万个样本时，这些比例作为最佳选择都是合理的。</p>
<p>但是在这个大数据的时代，趋势可能会变化，可能有多达100万个训练样本，而开发集，和测试集在总体数据中所占的比例就变小了，这是因为，<strong>开发集存在的意义是用来，测试不同的算法并确定哪种最好</strong>，所以开发集只要足够大到，能够用来在评估两种不同的算法，或是十种不同的算法时快速选出较好的一种，达成这个目标可能不需要多达20%的数据。所以如果有100万个训练样本，可能开发集只要1万个样本就足够了，足够用来评估两种算法中哪一种更好。与开发集相似，<strong>测试集的主要功能是，对训练好的分类器的性能，给出可信度较高的评估</strong>。同样如果可能有100万个样本，但是只要1万个，就足够评估单个分类器的性能，能够对其性能给出比较准确的估计了。</p>
<p>如果有100万个样本，而只需要1万个用作开发集，1万个用作测试集，那么1万个只是100万个的百分之一，所以比例就是98/1/1%。还有一些应用的样本可能多于100万个，分割比率可能会变成99.5/0.25/0.25%，或者开发集占0.4%，测试集占0.1%。</p>
<p>所以总结起来，<strong>当设定机器学习问题时，通常将数据分为训练集，开发集和测试集。如果数据集比较小，也许就可以采用传统的分割比率，但如果数据集大了很多，那也可以使开发集，和测试集远小于总数据20%，甚至远少于10%。</strong></p>
<p>当前的深度学习中还有一个趋势是，<strong>有越来越多的人的训练集与测试集的数据分布不匹配</strong>。假设构建一个应用，允许用户上传大量图片，目标是找出猫的图片再展示给用户，也许因为用户都是爱猫之人，而训练集可能来自网上下载的猫的图片，而开发集和测试集则包含用户用应用上传的图片，所以，一边是训练集可能有很多从网上爬取的图片，另一边是，开发集和测试集中有许多用户上传的图片，会发现许多网页上的图片都是高分辨率，专业制作过，构图也很漂亮的猫的图片，而用户上传的图则相对比较模糊，分辨率低，用手机在更加随意的情况下拍摄的，所以这可能就造成两种不同的分布，在这种情况下建议的经验法则是，<strong>确保开发集和测试集中的数据分布相同</strong>。</p>
<p><strong>Make sure that the dev and test sets come from the same distribution.</strong></p>
<p>即使没有测试集也许也是可以的。测试集的目的是给你一个无偏估计，来评价最终所选取的网络的性能。但<strong>如果不需要无偏的估计的话，没有测试集也许也没有问题</strong>。所以当只有开发集而没有测试集的时候，所做的就是用训练集尝试不同的模型结构，然后用开发集去评估它们，根据结果进一步迭代，并尝试得到一个好的模型，因为模型拟合了开发集中的数据，所以开发集不能给无偏的估计。</p>
<h4 id="Bias-Variance"><a href="#Bias-Variance" class="headerlink" title="Bias / Variance"></a>Bias / Variance</h4><ul>
<li>Bias，偏差，描述偏离度。</li>
<li>Variance，方差，描述集中度。</li>
</ul>
<img src="/2018/07/05/coursera-deeplearning-ai-c2-week1/bias_and_variance.jpg" alt="bias and variance" title="bias and variance">
<p>坐标中的⭕和×表示训练集。</p>
<p>左侧是用一条直线来区分样本数据，用逻辑回归可能画出图上的这条直线，这和训练数据的拟合度并不高，这样的分类我们称之为<strong>高偏差</strong>。或者换一种说法，称为<strong>欠拟合</strong>。</p>
<p>相对的，右侧的曲线，如果使用一个极为复杂的分类器，或许可以像图上画的这样完美区分训练数据，但看上去也并不是一个非常好的分类算法 这个<strong>高方差</strong>的分类器，我们也称之为<strong>过拟合</strong> 。</p>
<p>中间的一条曲线是比较合适的。</p>

<p>训练集的误差，至少可以知道算法是否可以很好的拟合训练集数据，然后总结出是否属于高偏差问题。然后通过观察同一个算法，在开发集上的误差了多少，可以知道这个算法是否有高方差问题。这样就能判断训练集上的算法是否在开发集上同样适用。上述结果都基于贝叶斯误差非常低，并且训练集和开发集都来自与同一个分布。</p>
<p>高偏差高方差的例子如下：</p>

<p>通过观察算法，在训练集和开发集的误差来诊断，它是否有高偏差或者高方差的问题，或许两者都有，或许都没有，基于算法遇到高偏差或高方差问题的不同情况，可以尝试不同的方法来进行改进。</p>
<h4 id="Basic-Recipe-for-Machine-Learning"><a href="#Basic-Recipe-for-Machine-Learning" class="headerlink" title="Basic Recipe for Machine Learning"></a>Basic Recipe for Machine Learning</h4><p>机器学习的基本准则如下图所示：</p>
<img src="/2018/07/05/coursera-deeplearning-ai-c2-week1/basic_recipe_for_machine_learning.jpg" alt="basic recipe for machine learning" title="basic recipe for machine learning">
<p>图中，找到一个新的神经网络结构，这个办法可能有效，也可能无效。把它写在括号里，是因为它是一种需要你亲自尝试的方法，也许最终能使它有效，也许不能。</p>
<p>但在当前这个深度学习和大数据的时代,只要能不断扩大所训练的网络的规模,只要能不断获得更多数据,虽然这两点都不是永远成立的,但如果这两点是可能的,那扩大网络几乎总是能够,减小偏差而不增大方差。只要用恰当的方式正则化的话，而获得更多数据几乎总是能够，减小方差而不增大偏差。</p>
<p>所以归根结底，有了这两步以后，再加上能够选取不同的网络来训练，以及获取更多数据的能力，就有了能够且只单独削减偏差或者能够并且单独削减方差，同时不会过多影响另一个指标的能力。这就是诸多原因中的一个，能够解释为何深度学习在监督学习中如此有用，以及为何在深度学习中，偏差与方差的权衡要不明显得多。这样你就不需小心地平衡两者，而是因为有了更多选择，可以单独削减偏差或单独削减方差，而不会同时增加方差或偏差。而且事实上当有了一个良好地正则化的网络时，训练一个更大的网络几乎从来没有坏处，当训练的神经网络太大时主要的代价只是计算时间。</p>
<h3 id="Regularizing-your-neural-network"><a href="#Regularizing-your-neural-network" class="headerlink" title="Regularizing your neural network"></a>Regularizing your neural network</h3><h4 id="Regularization-正则化"><a href="#Regularization-正则化" class="headerlink" title="Regularization(正则化)"></a>Regularization(正则化)</h4><h5 id="逻辑回归的正则化"><a href="#逻辑回归的正则化" class="headerlink" title="逻辑回归的正则化"></a>逻辑回归的正则化</h5><script type="math/tex; mode=display">
\min_{w,b} J(w,b)</script><p>正则化前：</p>
<script type="math/tex; mode=display">
J(w,b) = -\frac{1}{m}\sum_{i=1}^{m}[\mathcal{L}(\hat{y}^{(i)}, y^{(i)})]</script><p>$L_2$正则化后：</p>
<script type="math/tex; mode=display">
J(w,b) = -\frac{1}{m}\sum_{i=1}^{m}[\mathcal{L}(\hat{y}^{(i)}, y^{(i)})] + \frac{\lambda}{2m} \parallel w \parallel_2^2</script><p>其中，$\lambda$是正则化参数。</p>
<p>为什么只对参数w进行正则化呢? 为什么不把b的相关项也加进去呢？实际上可以这样做,但通常会把它省略掉。因为参数$w$往往是一个非常高维的参数矢量,尤其是在发生高方差问题的情况下,可能w有非常多的参数。而b只是单个数字，几乎所有的参数都集中在w中，而不是b中。即使你加上了最后这一项，实际上也不会起到太大的作用，因为b只是大量参数中的一个参数，在实践中通常就不费力气去包含它了。</p>
<p>$ L_2$正则化：</p>
<script type="math/tex; mode=display">\frac{\lambda}{2m} \parallel w \parallel_2^2 = \frac{\lambda}{2m}\sum_{i=1}^{m}{w_j^2} =\frac{\lambda}{2m} w^Tw</script><p>$ L_2$正则化是参数矢量w的欧几里得范数的平方。</p>
<p>$ L_1 $正则化：</p>
<script type="math/tex; mode=display">\frac{\lambda}{2m} \parallel w \parallel_1 = \frac{\lambda}{2m} \sum_{i=1}^{m}{|w_j|}</script><p>如果使用$ L_1 $正则化，最终$w$会变的稀疏（sparse），也就是包含很多0. 有些人认为这有助于压缩模型，因为有一部分参数是0，只需较少的内存来存储模型。然而在实践中发现，通过L1正则化让模型变得稀疏，带来的收效甚微。所以在压缩模型的目标上，它的作用不大，在训练网络时，L2正则化使用得频繁得多。 </p>
<blockquote>
<p>注：$L<em>1$范数，表示向量中每个元素绝对值的和：$$ \parallel x \parallel_1 =  \sum</em>{i=1}^{m}{|x<em>i|} <script type="math/tex">$L_2$范数,也称为欧几里得距离：</script> \parallel x \parallel_2 =  \sqrt{\sum</em>{i=1}^{m}{x_i^2}} $$<br>L2范数越小，可以使得x的每个元素都很小，接近于0。在回归里面，有人把有它的回归叫“岭回归”（Ridge Regression），有人也叫它<strong>权值衰减（Weight Decay）</strong>。越小的参数说明模型越简单，越简单的模型则越不容易产生过拟合现象。</p>
</blockquote>
<h5 id="神经网络的正则化"><a href="#神经网络的正则化" class="headerlink" title="神经网络的正则化"></a>神经网络的正则化</h5><p>正则化前：</p>
<script type="math/tex; mode=display">
J(w^{[1]},b^{[1]},\cdots,w^{[l]},b^{[l]}) = -\frac{1}{m}\sum_{i=1}^{m}[\mathcal{L}(\hat{y}^{(i)}, y^{(i)})]</script><p>正则化后：</p>
<script type="math/tex; mode=display">
J(w^{[1]},b^{[1]},\cdots,w^{[l]},b^{[l]}) = -\frac{1}{m}\sum_{i=1}^{m}[\mathcal{L}(\hat{y}^{(i)}, y^{(i)})] + \frac{\lambda}{2m} \sum_{i=1}^{l} \parallel w^{[l]} \parallel_F^2</script><p>其中，</p>
<script type="math/tex; mode=display">
 \parallel w^{[l]} \parallel_F^2 = \sum_{i=1}^{n^{[l-1]}}\sum_{j=1}^{n^{[l]}}(w_{ij}^{[l]})^2</script><p>这里矩阵范数的平方定义为,对于i和j,对矩阵中每一个元素的平方求和.如果想为这个求和加上索引，这个求和是i从1到n[l-1]，j从1到n[l]，因为w是一个n[l-1]列、n[l]行的矩阵,这些是第l-1层和第l层的隐藏单元数量单元数量或这个矩阵的范数，称为矩阵的<strong>弗罗贝尼乌斯范数</strong>。</p>
<p>$\lambda$是正则化参数。</p>
<script type="math/tex; mode=display">dw^{[l]} = from \,\,backpropagation + \frac{\lambda}{m} w^{[l]}</script><script type="math/tex; mode=display">
\begin{aligned}
w^{[l]} & =w^{[l]} - \alpha dw^{[l]} \\
& = w^{[l]} - \alpha[from \,\,backpropagation + \frac{\lambda}{m} w^{[l]}
& = w^{[l]} - \alpha dw^{[l]} \\
& = (1- \frac{\lambda}{m})w^{[l]} - \alpha[from \,\,backpropagation]
\end{aligned}</script><p>从上面的公式中可以看到，$w^{[l]}$项前面乘了一个小于1的数，也就是权重会减小，所以这个范数也被称为“权重衰减（weight decay）”。</p>
<h4 id="Why-regularization-reduces-overfitting"><a href="#Why-regularization-reduces-overfitting" class="headerlink" title="Why regularization reduces overfitting?"></a>Why regularization reduces overfitting?</h4><p><strong>为什么正则化能够防止过拟合呢? 为什么它有助于减少方差问题?</strong></p>
<p>左边是高偏差，右边是高方差，中间的是恰好的情况。</p>
<img src="/2018/07/05/coursera-deeplearning-ai-c2-week1/bias_and_variance.jpg" alt="bias and variance" title="bias and variance">
<p>关于这个问题的一个直观理解就是，如果你把正则项λ设置的很大，权重矩阵W就会被设置为非常接近0的值。因此这个直观理解就是：把很多隐藏单元的权重，设置的太接近0了而导致，一些隐藏单元的影响被消除了。如果是这种情况，那么就会使这个大大简化的神经网络变成一个很小的神经网络。事实上，这种情况与逻辑回归单元很像，但很可能是网络的深度更大了，因此这就会使，这个过拟合网络带到更加接近左边高偏差的状态。但是λ存在一个中间值，能够得到一个更加接近中间这个刚刚好的状态。</p>
<img src="/2018/07/05/coursera-deeplearning-ai-c2-week1/intuitive_understanding_of_regularizing.jpg" alt="intuitive understanding of regularizing" title="intuitive understanding of regularizing">
<p>直觉上认为上图中蓝色被覆盖的部分，这些隐藏单元的影响被完全消除了，其实并不完全正确。实际上网络仍在使用所有的隐藏单元，但每个隐藏单元的影响变得非常小了。但最终得到的这个简单的网络，看起来就像一个不容易过拟合的小型的网络。</p>
<p>现在通过另一个例子直观理解一下，为什么正则化可以帮助防止过拟合，在这个例子中，假设使用的，tanh激活函数。使用$g(z)$表示$tanh(z)$，因此这种情况下，可以发现只要Z的值很小，比如Z只涉及很小范围的参数，tanh曲线中中间的一小部分，那么其实是在使用tanh函数的线性的条件部分。只有Z的值被允许取到更大的值或者像这种小一点的值的时候，激活函数才开始展现出它的非线性的能力。因此直觉就是，如果λ值，即正则化参数被设置的很大的话，那么激活函数的参数实际上会变小，因为代价函数的参数会被不能过大，并且如果W很小那么由于，Z等于W这项再加上b，但如果W非常非常小，那么Z也会非常小。特别是如果Z的值相对都很小时，就在曲线的中间部分范围内取值的话，那么g(z)函数就会接近于线性函数，因此，每一层都几乎是线性的，就像线性回归一样。如果每层都是线性的，那么整个网络就是线性网络。因此即使一个很深的神经网络，如果使用线性激活函数，最终也只能计算线性的函数，因此就不能拟合那些很复杂的决策函数，也不过度拟合那些，数据集的非线性决策平面。</p>
<p>总结一下，如果正则化变得非常大，而参数W很小，那么Z就会相对很小。此时先暂时忽略b的影响，Z会相对变小，即Z只在小范围内取值，那么激活函数如果是tanh的话，这个激活函数就会呈现相对线性，那么整个神经网络就只能计算一些，离线性函数很近的值，也就是相对比较简单的函数，而不能计算，很复杂的非线性函数，因此就不大容易过拟合了。</p>
<h4 id="Dropout-Regularization-随机失活正则化（丢弃法）"><a href="#Dropout-Regularization-随机失活正则化（丢弃法）" class="headerlink" title="Dropout Regularization(随机失活正则化（丢弃法）)"></a>Dropout Regularization(随机失活正则化（丢弃法）)</h4><p>假设你训练下图所示的神经网络并发现过拟合现象，可以使用随机失活技术来处理它。使用随机失活技术，遍历这个网络的每一层，并且为丢弃(drop)网络中的某个节点置一个概率值（比如50%），即对于网络中的每一层，使这个节点有50%的几率被保留,50%的的几率被丢弃。最后得到的是一个小得多的、被简化了很多的网络。然后再做反向传播训练。</p>

<h5 id="dropout的实现："><a href="#dropout的实现：" class="headerlink" title="dropout的实现："></a>dropout的实现：</h5><p>有几种方法可以实现随机失活算法，最常用的一种是反向随机失活(inverted dropout) 。</p>
<p>Inverted dropout:反向随机失活的实现：（以3层网络为例）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">layer l = 3</div><div class="line"></div><div class="line">keep-prob = 0.8  # 保留网络中某一节点的概率值，0.8意味着layer中的节点有20%的概率被丢弃</div><div class="line"></div><div class="line">d3 = np.random.rand(a3.shape[0],a3.shape[1] ) &lt; keep-prob) ? 1 : 0</div><div class="line"></div><div class="line">a3 = np.multiply(a3,d3)  # 把某些元素置为0，表示此节点被隐藏</div><div class="line"></div><div class="line">a3 /= keep-prob</div></pre></td></tr></table></figure>
<p>最后一步的作用是”保证下一层 $Z^{[4]} = W^{[4]}  a^{[3]} + b^{[4]}$ 的期望值不会降低。</p>
<p>测试阶段不使用dropout。</p>
<h4 id="Understanding-Dropout"><a href="#Understanding-Dropout" class="headerlink" title="Understanding Dropout"></a>Understanding Dropout</h4><p><strong>Dropout为什么有效？</strong><br><strong>Can’t rely on any one feature,so have to spread out weights.</strong></p>
<p>不同的层，可以设置不同的keep-prop。</p>
<p><strong>如果觉得某一层比其他层更容易发生过拟合，给这一层设置更低的保留率（keep-prop）</strong>。这样的缺点是在交叉验证 (网格) 搜索时，会有更多的超参数 (运行会更费时)。另一个选择就是对一些层使用dropout (留存率相同)，而另一些不使用。这样的话，就只有一个超参数了。</p>
<p>需要记住dropout是一种正则化技术,目的是防止过拟合。所以，<strong>除非算法已经过拟合了，否则是不会考虑使用dropout的。</strong></p>
<p>dropout的另一个缺点是让代价函数J，变得不那么明确。因为每一次迭代，都有一些神经元随机失活，所以检验梯度下降算法表现的时候，会发现很难确定代价函数是否已经定义的足够好 (随着迭代 值不断变小)。通常这个时候可以关闭dropout，把留存率设为1。然后再运行代码并确保代价函数J 是单调递减的，最后再打开dropout并期待使用dropout的时候没有引入别的错误。 </p>
<h4 id="Other-regularization-methods"><a href="#Other-regularization-methods" class="headerlink" title="Other regularization methods"></a>Other regularization methods</h4><p>其他的一些正则化的方法：</p>
<ul>
<li>Data augmentation（数据扩增）:<ul>
<li><img src="/2018/07/05/coursera-deeplearning-ai-c2-week1/data_augmentation.jpg" alt="Data augmentation" title="Data augmentation"></li>
<li>一只猫，那它水平翻转之后还是一只猫，随机放大图片的一部分，这很可能仍然是一只猫。对于字符识别，可以通过给数字加上随机的旋转和变形。 </li>
</ul>
</li>
<li>Early stoping(早终止法)<ul>
<li><img src="/2018/07/05/coursera-deeplearning-ai-c2-week1/early_stoping.jpg" alt="early stoping" title="early stoping"></li>
<li>在某次次迭代附近 ，神经网络表现得最好，然后把神经网络的训练过程停住，并且选取这个(最小)开发集误差所对应的值。</li>
<li>Early stopiing有个缺点。可以把机器学习过程看作几个不同的步骤，其中之一是：需要一个算法，能够最优化成本函数J。Early stopping的主要缺点就是,它把这两个任务结合了，所以无法分开解决这两个问题。因为提早停止了梯度下降，意味着打断了优化成本函数J的过程。</li>
</ul>
</li>
</ul>
<h3 id="Setting-up-your-optimization-problem"><a href="#Setting-up-your-optimization-problem" class="headerlink" title="Setting up your optimization problem"></a>Setting up your optimization problem</h3><h4 id="Normalizing-inputs"><a href="#Normalizing-inputs" class="headerlink" title="Normalizing inputs"></a>Normalizing inputs</h4><ul>
<li><ol>
<li>均值归一：<script type="math/tex; mode=display">\mu = \frac{1}{m} \sum_{i=1}^m x^{(i)} \,\,\,\,\,\,\,\,\,  x= x - \mu</script></li>
</ol>
</li>
<li><ol>
<li>方差归一化： <script type="math/tex; mode=display">\sigma ^ {2} = \frac{1}{m} \sum_{i=1}^m (x^{(i)})^2  \,\,\,\,  x=   \frac{x}{\sigma ^2}</script></li>
</ol>
</li>
</ul>
<img src="/2018/07/05/coursera-deeplearning-ai-c2-week1/normalizing_training_sets.jpg" alt="Normalizing training sets" title="Normalizing training sets">
<p><strong>为什么Normalizing有效？</strong></p>
<img src="/2018/07/05/coursera-deeplearning-ai-c2-week1/why_normalize_inputs.jpg" alt="Why normalize inputs" title="Why normalize inputs">
<p>为什么要对输入特征进行归一化呢? 像上图右上方这样的代价函数，如果使用了未归一化的输入特征，代价函数看起来就会像一个压扁了的碗。 如果把这个函数的等值线画出来，就会有一个像这样的扁长的函数。而如果将特征进行归一化后，代价函数通常就会看起来更对称。</p>
<p>如果对左图的那种代价函数使用梯度下降法，那可能必须使用非常小的学习率 。如果等值线更趋近于圆形，那无论从哪儿开始，梯度下降法几乎都能直接朝向最小值而去，可以在梯度下降中采用更长的步长，而无需像左图那样来回摇摆缓慢挪动。</p>
<p>当特征的范围有非常大的不同时，譬如一个特征是1到1000，而另一个是0到1，那就会着实地削弱优化算法的表现了。但只要将它们变换，使均值皆为0，方差皆为1，就能保证所有的特征尺度都相近，这通常也能让帮助学习算法运行得更快。所以<strong>如果输入特征的尺度非常不同，比如可能有些特征取值范围是0到1，有些是1到1000，那对输入进行归一化就很重要</strong>。而如果输入特征本来尺度就相近，那么这一步就不那么重要。不过因为归一化的步骤几乎从来没有任何害处，所以一般总是进行归一化。 </p>
<h4 id="Vanishing-Exploding-gradients"><a href="#Vanishing-Exploding-gradients" class="headerlink" title="Vanishing / Exploding gradients"></a>Vanishing / Exploding gradients</h4><p>当训练神经网络时会遇到一个问题，尤其是当训练层数非常多的神经网络时，这个问题就是<strong>梯度消失和梯度爆炸</strong>。它的意思是当在训练一个深度神经网络的时候，损失函数的导数，有时会变得非常大，或者非常小甚至是呈指数级减小。</p>
<img src="/2018/07/05/coursera-deeplearning-ai-c2-week1/l_layer_network.jpg" alt="l layer network" title="l layer network">
<p>假设：$g(z)=z,b=0$</p>
<script type="math/tex; mode=display">
\hat{y} =w^{[l]}w^{[l-1]}w^{[l-2]}\cdots w^{[2]}w^{[1]}x</script><p>假设： </p>
<script type="math/tex; mode=display">
w^{[l]} = \begin{bmatrix} 1.5 & 0 \\ 0 & 1.5 \\ \end{bmatrix}</script><p>则 $\hat{y} = 1.5^{L}x $，如果L很大，则$\hat{y}$呈指数级增长。</p>
<p>反之，假设： </p>
<script type="math/tex; mode=display">
w^{[l]} = \begin{bmatrix} 0.5 & 0 \\ 0 & 0.5 \\ \end{bmatrix}</script><p>则 $\hat{y} = 0.5^{L}x $，如果L很大，则$\hat{y}$会很小。</p>
<p>这就是梯度爆炸或者消失产生的原因。</p>
<p>在这么深的神经网络里，如果激活函数或梯度作为L的函数指数级的增加或减少，这些值会变得非常大或非常小，这会让训练变得非常困难。尤其是如果梯度比L要小指数级别， 梯度下降会很用很小很小步的走，梯度下降会用很长的时间才能有任何学习。</p>
<p>解决梯度爆炸或消失的方法是：谨慎选择初始化权重方法。</p>
<h4 id="Weight-Initialization-for-Deep-Networks"><a href="#Weight-Initialization-for-Deep-Networks" class="headerlink" title="Weight Initialization for Deep Networks"></a>Weight Initialization for Deep Networks</h4><img src="/2018/07/05/coursera-deeplearning-ai-c2-week1/single_neuron_example.jpg" alt="single neuron example" title="single neuron example">
<p>如上图的单个的神经元会输入4个特征，从x1到x4，然后用a=g(z)激活，最后得到y。</p>
<script type="math/tex; mode=display">z = w_1*x_1+w_2*x_2+···+w_n*x_n \,\,\,\,\, b=0</script><p>为了不让z项太大或者太小,那么n项的数值越大，就会希望$W_i$的值越小。因为z是$w_i*x_i$的加和。因此，如果加和了很多这样的项，就会希望每一项就尽可能地小。一个合理的做法是，让变量wi等于1/n，这里的n是指输入一个神经元的特征数。</p>
<p>具体做法为：</p>
<script type="math/tex; mode=display">
W^{[l]} = np.random.rand(shape) * np.sqrt(\frac{2}{n^{[l-1]}})</script><blockquote>
<p>注：这个做法是针对激活函数为$Rule$的情况。</p>
</blockquote>
<p>虽然这样不能完全解决问题，但它降低了梯度消失和梯度爆炸问题的程度。因为这种做法通过设置权重矩阵W，使得W不会比1大很多，也不会比1小很多。因此梯度不会过快地膨胀或者消失。</p>
<p>其他的激活函数的做法：</p>
<ul>
<li>tanh函数（Xavier初始化方法）：<script type="math/tex; mode=display">W^{[l]} = np.random.rand(shape) * np.sqrt(\frac{1}{n^{[l-1]}})</script></li>
<li>Rule也可以尝试如下方法：<script type="math/tex; mode=display">W^{[l]} = np.random.rand(shape) * np.sqrt(\frac{2}{n^{[l]}+ n^{[l-1]}})</script></li>
</ul>
<h4 id="Gradient-checking"><a href="#Gradient-checking" class="headerlink" title="Gradient checking"></a>Gradient checking</h4><p>原理是如下公式：</p>
<script type="math/tex; mode=display">\frac{\partial J}{\partial \theta} = \lim_{\varepsilon \to 0} \frac{J(\theta + \varepsilon) - J(\theta - \varepsilon)}{2 \varepsilon}</script><p>梯度检查的流程：</p>
<ul>
<li>1.Take $W^{[1]},b^{[1]},\cdots,W^{[L]},b^{[L]}$ and reshape into a big vector $\theta$</li>
<li>2.Take $dW^{[1]},db^{[1]},\cdots,dW^{[L]},db^{[L]}$ and reshape into a big vector $d\theta$</li>
<li>3.Check: Is $d\theta$ the gradient of $J(\theta)$?<ul>
<li>First compute “gradapprox” using the formula above (1) and a small value of $\varepsilon$. Here are the Steps to follow:<ol>
<li>$\theta^{+} = \theta + \varepsilon$</li>
<li>$\theta^{-} = \theta - \varepsilon$</li>
<li>$J^{+} = J(\theta^{+})$</li>
<li>$J^{-} = J(\theta^{-})$</li>
<li>$gradapprox = \frac{J^{+} - J^{-}}{2  \varepsilon}$</li>
</ol>
</li>
<li>Then compute the gradient using backward propagation, and store the result in a variable “grad”</li>
<li>Finally, compute the relative difference between “gradapprox” and the “grad” using the following formula:<script type="math/tex; mode=display">difference = \frac {\mid\mid grad - gradapprox \mid\mid_2}{\mid\mid grad \mid\mid_2 + \mid\mid gradapprox \mid\mid_2}</script>You will need 3 Steps to compute this formula:<ul>
<li>1’. compute the numerator using np.linalg.norm(…)</li>
<li>2’. compute the denominator. You will need to call np.linalg.norm(…) twice.</li>
<li>3’. divide them.</li>
</ul>
</li>
<li>If this difference is small (say less than $10^{-7}$), you can be quite confident that you have computed your gradient correctly. Otherwise, there may be a mistake in the gradient computation. </li>
</ul>
</li>
</ul>
<h4 id="Gradient-Checking-Implementation-Notes"><a href="#Gradient-Checking-Implementation-Notes" class="headerlink" title="Gradient Checking Implementation Notes"></a>Gradient Checking Implementation Notes</h4><ul>
<li>Don’t use in training – only to debug</li>
<li>If algorithm fails grad check, look at components to try to identify bug.</li>
<li>Remember regularization.</li>
<li>Doesn’t work with dropout.</li>
<li>Run at random initialization; perhaps again after some training.</li>
</ul>
<h2 id="编程练习"><a href="#编程练习" class="headerlink" title="编程练习"></a>编程练习</h2><h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><h3 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h3><h3 id="Gradient-Checking"><a href="#Gradient-Checking" class="headerlink" title="Gradient Checking"></a>Gradient Checking</h3><p>Welcome to the final assignment for this week! In this assignment you will learn to implement and use gradient checking. </p>
<p>You are part of a team working to make mobile payments available globally, and are asked to build a deep learning model to detect fraud—whenever someone makes a payment, you want to see if the payment might be fraudulent, such as if the user’s account has been taken over by a hacker. </p>
<p>But backpropagation is quite challenging to implement, and sometimes has bugs. Because this is a mission-critical application, your company’s CEO wants to be really certain that your implementation of backpropagation is correct. Your CEO says, “Give me a proof that your backpropagation is actually working!” To give this reassurance, you are going to use “gradient checking”.</p>
<p>Let’s do it!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">from</span> testCases <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> gc_utils <span class="keyword">import</span> sigmoid, relu, dictionary_to_vector, vector_to_dictionary, gradients_to_vector</div></pre></td></tr></table></figure>
<h4 id="1-How-does-gradient-checking-work"><a href="#1-How-does-gradient-checking-work" class="headerlink" title="1) How does gradient checking work?"></a>1) How does gradient checking work?</h4><p>Backpropagation computes the gradients $\frac{\partial J}{\partial \theta}$, where $\theta$ denotes the parameters of the model. $J$ is computed using forward propagation and your loss function.</p>
<p>Because forward propagation is relatively easy to implement, you’re confident you got that right, and so you’re almost  100% sure that you’re computing the cost $J$ correctly. Thus, you can use your code for computing $J$ to verify the code for computing $\frac{\partial J}{\partial \theta}$. </p>
<p>Let’s look back at the definition of a derivative (or gradient):</p>
<script type="math/tex; mode=display">\frac{\partial J}{\partial \theta} = \lim_{\varepsilon \to 0} \frac{J(\theta + \varepsilon) - J(\theta - \varepsilon)}{2 \varepsilon}</script><p>If you’re not familiar with the “$\displaystyle \lim_{\varepsilon \to 0}$” notation, it’s just a way of saying “when $\varepsilon$ is really really small.”</p>
<p>We know the following:</p>
<ul>
<li>$\frac{\partial J}{\partial \theta}$ is what you want to make sure you’re computing correctly. </li>
<li>You can compute $J(\theta + \varepsilon)$ and $J(\theta - \varepsilon)$ (in the case that $\theta$ is a real number), since you’re confident your implementation for $J$ is correct. </li>
</ul>
<p>Lets use equation (1) and a small value for $\varepsilon$ to convince your CEO that your code for computing  $\frac{\partial J}{\partial \theta}$ is correct!</p>
<h4 id="2-1-dimensional-gradient-checking"><a href="#2-1-dimensional-gradient-checking" class="headerlink" title="2) 1-dimensional gradient checking"></a>2) 1-dimensional gradient checking</h4><p>Consider a 1D linear function $J(\theta) = \theta x$. The model contains only a single real-valued parameter $\theta$, and takes $x$ as input.</p>
<p>You will implement code to compute $J(.)$ and its derivative $\frac{\partial J}{\partial \theta}$. You will then use gradient checking to make sure your derivative computation for $J$ is correct. </p>
<img src="/2018/07/05/coursera-deeplearning-ai-c2-week1/1Dgrad_kiank.png" alt="Figure 1: 1D linear model" title="Figure 1: 1D linear model">
<p>The diagram above shows the key computation steps: First start with $x$, then evaluate the function $J(x)$ (“forward propagation”). Then compute the derivative $\frac{\partial J}{\partial \theta}$ (“backward propagation”). </p>
<p><strong>Exercise</strong>: implement “forward propagation” and “backward propagation” for this simple function. I.e., compute both $J(.)$ (“forward propagation”) and its derivative with respect to $\theta$ (“backward propagation”), in two separate functions. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># GRADED FUNCTION: forward_propagation</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_propagation</span><span class="params">(x, theta)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Implement the linear forward propagation (compute J) presented in Figure 1 (J(theta) = theta * x)</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    x -- a real-valued input</span></div><div class="line"><span class="string">    theta -- our parameter, a real number as well</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    J -- the value of function J, computed using the formula J(theta) = theta * x</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    <span class="comment">### START CODE HERE ### (approx. 1 line)</span></div><div class="line">    J = x * theta</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> J</div></pre></td></tr></table></figure>
<p><strong>Exercise</strong>: Now, implement the backward propagation step (derivative computation) of Figure 1. That is, compute the derivative of $J(\theta) = \theta x$ with respect to $\theta$. To save you from doing the calculus, you should get $dtheta = \frac { \partial J }{ \partial \theta} = x$.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># GRADED FUNCTION: backward_propagation</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward_propagation</span><span class="params">(x, theta)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Computes the derivative of J with respect to theta (see Figure 1).</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    x -- a real-valued input</span></div><div class="line"><span class="string">    theta -- our parameter, a real number as well</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    dtheta -- the gradient of the cost with respect to theta</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    <span class="comment">### START CODE HERE ### (approx. 1 line)</span></div><div class="line">    dtheta = x</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dtheta</div></pre></td></tr></table></figure>
<p><strong>Exercise</strong>: To show that the <code>backward_propagation()</code> function is correctly computing the gradient $\frac{\partial J}{\partial \theta}$, let’s implement gradient checking.</p>
<p><strong>Instructions</strong>:</p>
<ul>
<li>First compute “gradapprox” using the formula above (1) and a small value of $\varepsilon$. Here are the Steps to follow:<ol>
<li>$\theta^{+} = \theta + \varepsilon$</li>
<li>$\theta^{-} = \theta - \varepsilon$</li>
<li>$J^{+} = J(\theta^{+})$</li>
<li>$J^{-} = J(\theta^{-})$</li>
<li>$gradapprox = \frac{J^{+} - J^{-}}{2  \varepsilon}$</li>
</ol>
</li>
<li>Then compute the gradient using backward propagation, and store the result in a variable “grad”</li>
<li>Finally, compute the relative difference between “gradapprox” and the “grad” using the following formula:<script type="math/tex; mode=display">difference = \frac {\mid\mid grad - gradapprox \mid\mid_2}{\mid\mid grad \mid\mid_2 + \mid\mid gradapprox \mid\mid_2}</script>You will need 3 Steps to compute this formula:<ul>
<li>1’. compute the numerator using np.linalg.norm(…)</li>
<li>2’. compute the denominator. You will need to call np.linalg.norm(…) twice.</li>
<li>3’. divide them.</li>
</ul>
</li>
<li>If this difference is small (say less than $10^{-7}$), you can be quite confident that you have computed your gradient correctly. Otherwise, there may be a mistake in the gradient computation. </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#GRADED FUNCTION: gradient_check</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_check</span><span class="params">(x, theta, epsilon = <span class="number">1e-7</span>)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Implement the backward propagation presented in Figure 1.</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    x -- a real-valued input</span></div><div class="line"><span class="string">    theta -- our parameter, a real number as well</span></div><div class="line"><span class="string">    epsilon -- tiny shift to the input to compute approximated gradient with formula(1)</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    difference -- difference (2) between the approximated gradient and the backward propagation gradient</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    <span class="comment"># Compute gradapprox using left side of formula (1). epsilon is small enough, you don't need to worry about the limit.</span></div><div class="line">    <span class="comment">### START CODE HERE ### (approx. 5 lines)</span></div><div class="line">    thetaplus = theta + epsilon                               <span class="comment"># Step 1</span></div><div class="line">    thetaminus = theta - epsilon                              <span class="comment"># Step 2</span></div><div class="line">    J_plus = forward_propagation(x, thetaplus)                                  <span class="comment"># Step 3</span></div><div class="line">    J_minus = forward_propagation(x, thetaminus)                                    <span class="comment"># Step 4</span></div><div class="line">    gradapprox = (J_plus - J_minus) / (<span class="number">2</span> * epsilon)                              <span class="comment"># Step 5</span></div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="comment"># Check if gradapprox is close enough to the output of backward_propagation()</span></div><div class="line">    <span class="comment">### START CODE HERE ### (approx. 1 line)</span></div><div class="line">    grad = backward_propagation(x, theta)</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="comment">### START CODE HERE ### (approx. 1 line)</span></div><div class="line">    numerator = np.linalg.norm(grad - gradapprox)                                <span class="comment"># Step 1'</span></div><div class="line">    denominator = np.linalg.norm(grad) + np.linalg.norm(gradapprox)                             <span class="comment"># Step 2'</span></div><div class="line">    difference = numerator / denominator                              <span class="comment"># Step 3'</span></div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> difference &lt; <span class="number">1e-7</span>:</div><div class="line">        <span class="keyword">print</span> (<span class="string">"The gradient is correct!"</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">print</span> (<span class="string">"The gradient is wrong!"</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> difference</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x, theta = <span class="number">2</span>, <span class="number">4</span></div><div class="line">difference = gradient_check(x, theta)</div><div class="line">print(<span class="string">"difference = "</span> + str(difference))</div></pre></td></tr></table></figure>
<p><strong>Expected Output</strong>:</p>
<pre><code>The gradient is correct!
difference
     2.9193358103083e-10
</code></pre><p>Congrats, the difference is smaller than the $10^{-7}$ threshold. So you can have high confidence that you’ve correctly computed the gradient in <code>backward_propagation()</code>. </p>
<p>Now, in the more general case, your cost function $J$ has more than a single 1D input. When you are training a neural network, $\theta$ actually consists of multiple matrices $W^{[l]}$ and biases $b^{[l]}$! It is important to know how to do a gradient check with higher-dimensional inputs. Let’s do it!</p>
<h4 id="3-N-dimensional-gradient-checking"><a href="#3-N-dimensional-gradient-checking" class="headerlink" title="3) N-dimensional gradient checking"></a>3) N-dimensional gradient checking</h4><p>The following figure describes the forward and backward propagation of your fraud detection model.</p>
<img src="/2018/07/05/coursera-deeplearning-ai-c2-week1/NDgrad_kiank.png" alt="Figure 2: deep neural network[LINEAR -> RELU -> LINEAR -> RELU -> LINEAR -> SIGMOID]" title="Figure 2: deep neural network[LINEAR -> RELU -> LINEAR -> RELU -> LINEAR -> SIGMOID]">
<p>Let’s look at your implementations for forward propagation and backward propagation. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_propagation_n</span><span class="params">(X, Y, parameters)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Implements the forward propagation (and computes the cost) presented in Figure 3.</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    X -- training set for m examples</span></div><div class="line"><span class="string">    Y -- labels for m examples </span></div><div class="line"><span class="string">    parameters -- python dictionary containing your parameters "W1", "b1", "W2", "b2", "W3", "b3":</span></div><div class="line"><span class="string">                    W1 -- weight matrix of shape (5, 4)</span></div><div class="line"><span class="string">                    b1 -- bias vector of shape (5, 1)</span></div><div class="line"><span class="string">                    W2 -- weight matrix of shape (3, 5)</span></div><div class="line"><span class="string">                    b2 -- bias vector of shape (3, 1)</span></div><div class="line"><span class="string">                    W3 -- weight matrix of shape (1, 3)</span></div><div class="line"><span class="string">                    b3 -- bias vector of shape (1, 1)</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    cost -- the cost function (logistic cost for one example)</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    <span class="comment"># retrieve parameters</span></div><div class="line">    m = X.shape[<span class="number">1</span>]</div><div class="line">    W1 = parameters[<span class="string">"W1"</span>]</div><div class="line">    b1 = parameters[<span class="string">"b1"</span>]</div><div class="line">    W2 = parameters[<span class="string">"W2"</span>]</div><div class="line">    b2 = parameters[<span class="string">"b2"</span>]</div><div class="line">    W3 = parameters[<span class="string">"W3"</span>]</div><div class="line">    b3 = parameters[<span class="string">"b3"</span>]</div><div class="line"></div><div class="line">    <span class="comment"># LINEAR -&gt; RELU -&gt; LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID</span></div><div class="line">    Z1 = np.dot(W1, X) + b1</div><div class="line">    A1 = relu(Z1)</div><div class="line">    Z2 = np.dot(W2, A1) + b2</div><div class="line">    A2 = relu(Z2)</div><div class="line">    Z3 = np.dot(W3, A2) + b3</div><div class="line">    A3 = sigmoid(Z3)</div><div class="line"></div><div class="line">    <span class="comment"># Cost</span></div><div class="line">    logprobs = np.multiply(-np.log(A3),Y) + np.multiply(-np.log(<span class="number">1</span> - A3), <span class="number">1</span> - Y)</div><div class="line">    cost = <span class="number">1.</span>/m * np.sum(logprobs)</div><div class="line">    </div><div class="line">    cache = (Z1, A1, W1, b1, Z2, A2, W2, b2, Z3, A3, W3, b3)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> cost, cache</div></pre></td></tr></table></figure>
<p>Now, run backward propagation.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">backward_propagation_n</span><span class="params">(X, Y, cache)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Implement the backward propagation presented in figure 2.</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    X -- input datapoint, of shape (input size, 1)</span></div><div class="line"><span class="string">    Y -- true "label"</span></div><div class="line"><span class="string">    cache -- cache output from forward_propagation_n()</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    gradients -- A dictionary with the gradients of the cost with respect to each parameter, activation and pre-activation variables.</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    m = X.shape[<span class="number">1</span>]</div><div class="line">    (Z1, A1, W1, b1, Z2, A2, W2, b2, Z3, A3, W3, b3) = cache</div><div class="line">    </div><div class="line">    dZ3 = A3 - Y</div><div class="line">    dW3 = <span class="number">1.</span>/m * np.dot(dZ3, A2.T)</div><div class="line">    db3 = <span class="number">1.</span>/m * np.sum(dZ3, axis=<span class="number">1</span>, keepdims = <span class="keyword">True</span>)</div><div class="line">    </div><div class="line">    dA2 = np.dot(W3.T, dZ3)</div><div class="line">    dZ2 = np.multiply(dA2, np.int64(A2 &gt; <span class="number">0</span>))</div><div class="line">    dW2 = <span class="number">1.</span>/m * np.dot(dZ2, A1.T)</div><div class="line">    db2 = <span class="number">1.</span>/m * np.sum(dZ2, axis=<span class="number">1</span>, keepdims = <span class="keyword">True</span>)</div><div class="line">    </div><div class="line">    dA1 = np.dot(W2.T, dZ2)</div><div class="line">    dZ1 = np.multiply(dA1, np.int64(A1 &gt; <span class="number">0</span>))</div><div class="line">    dW1 = <span class="number">1.</span>/m * np.dot(dZ1, X.T)</div><div class="line">    db1 = <span class="number">1.</span>/m * np.sum(dZ1, axis=<span class="number">1</span>, keepdims = <span class="keyword">True</span>)</div><div class="line">    </div><div class="line">    gradients = &#123;<span class="string">"dZ3"</span>: dZ3, <span class="string">"dW3"</span>: dW3, <span class="string">"db3"</span>: db3,</div><div class="line">                 <span class="string">"dA2"</span>: dA2, <span class="string">"dZ2"</span>: dZ2, <span class="string">"dW2"</span>: dW2, <span class="string">"db2"</span>: db2,</div><div class="line">                 <span class="string">"dA1"</span>: dA1, <span class="string">"dZ1"</span>: dZ1, <span class="string">"dW1"</span>: dW1, <span class="string">"db1"</span>: db1&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> gradients</div></pre></td></tr></table></figure>
<p>You obtained some results on the fraud detection test set but you are not 100% sure of your model. Nobody’s perfect! Let’s implement gradient checking to verify if your gradients are correct.</p>
<p><strong>How does gradient checking work?</strong>.</p>
<p>As in 1) and 2), you want to compare “gradapprox” to the gradient computed by backpropagation. The formula is still:</p>
<script type="math/tex; mode=display">\frac{\partial J}{\partial \theta} = \lim_{\varepsilon \to 0} \frac{J(\theta + \varepsilon) - J(\theta - \varepsilon)}{2 \varepsilon}</script><p>However, $\theta$ is not a scalar anymore. It is a dictionary called “parameters”. We implemented a function “<code>dictionary_to_vector()</code>“ for you. It converts the “parameters” dictionary into a vector called “values”, obtained by reshaping all parameters (W1, b1, W2, b2, W3, b3) into vectors and concatenating them.</p>
<p>The inverse function is “<code>vector_to_dictionary</code>“ which outputs back the “parameters” dictionary.</p>
<img src="/2018/07/05/coursera-deeplearning-ai-c2-week1/dictionary_to_vector.png" alt="Figure 3: dictionary_to_vector() and vector_to_dictionary().You will need these functions in gradient_check_n()" title="Figure 3: dictionary_to_vector() and vector_to_dictionary().You will need these functions in gradient_check_n()">
<p>We have also converted the “gradients” dictionary into a vector “grad” using gradients_to_vector(). You don’t need to worry about that.</p>
<p><strong>Exercise</strong>: Implement gradient_check_n().</p>
<p><strong>Instructions</strong>: Here is pseudo-code that will help you implement the gradient check.</p>
<p>For each i in num_parameters:</p>
<ul>
<li>To compute <code>J_plus[i]</code>:<ol>
<li>Set $\theta^{+}$ to <code>np.copy(parameters_values)</code></li>
<li>Set $\theta^{+}_i$ to $\theta^{+}_i + \varepsilon$</li>
<li>Calculate $J^{+}_i$ using to <code>forward_propagation_n(x, y, vector_to_dictionary(</code>$\theta^{+}$ <code>))</code>.     </li>
</ol>
</li>
<li>To compute <code>J_minus[i]</code>: do the same thing with $\theta^{-}$</li>
<li>Compute $gradapprox[i] = \frac{J^{+}_i - J^{-}_i}{2 \varepsilon}$</li>
</ul>
<p>Thus, you get a vector gradapprox, where gradapprox[i] is an approximation of the gradient with respect to <code>parameter_values[i]</code>. You can now compare this gradapprox vector to the gradients vector from backpropagation. Just like for the 1D case (Steps 1’, 2’, 3’), compute: </p>
<script type="math/tex; mode=display">difference = \frac {\| grad - gradapprox \|_2}{\| grad \|_2 + \| gradapprox \|_2 }</script><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># GRADED FUNCTION: gradient_check_n</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_check_n</span><span class="params">(parameters, gradients, X, Y, epsilon = <span class="number">1e-7</span>)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Checks if backward_propagation_n computes correctly the gradient of the cost output by forward_propagation_n</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    parameters -- python dictionary containing your parameters "W1", "b1", "W2", "b2", "W3", "b3":</span></div><div class="line"><span class="string">    grad -- output of backward_propagation_n, contains gradients of the cost with respect to the parameters. </span></div><div class="line"><span class="string">    x -- input datapoint, of shape (input size, 1)</span></div><div class="line"><span class="string">    y -- true "label"</span></div><div class="line"><span class="string">    epsilon -- tiny shift to the input to compute approximated gradient with formula(1)</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    difference -- difference (2) between the approximated gradient and the backward propagation gradient</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    <span class="comment"># Set-up variables</span></div><div class="line">    parameters_values, _ = dictionary_to_vector(parameters)</div><div class="line">    grad = gradients_to_vector(gradients)</div><div class="line">    num_parameters = parameters_values.shape[<span class="number">0</span>]</div><div class="line">    J_plus = np.zeros((num_parameters, <span class="number">1</span>))</div><div class="line">    J_minus = np.zeros((num_parameters, <span class="number">1</span>))</div><div class="line">    gradapprox = np.zeros((num_parameters, <span class="number">1</span>))</div><div class="line">    </div><div class="line">    <span class="comment"># Compute gradapprox</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num_parameters):</div><div class="line">        </div><div class="line">        <span class="comment"># Compute J_plus[i]. Inputs: "parameters_values, epsilon". Output = "J_plus[i]".</span></div><div class="line">        <span class="comment"># "_" is used because the function you have to outputs two parameters but we only care about the first one</span></div><div class="line">        <span class="comment">### START CODE HERE ### (approx. 3 lines)</span></div><div class="line">        thetaplus =  np.copy(parameters_values)                                      <span class="comment"># Step 1</span></div><div class="line">        thetaplus[i][<span class="number">0</span>] =  thetaplus[i][<span class="number">0</span>] + epsilon                               <span class="comment"># Step 2</span></div><div class="line">        J_plus[i], _ =  forward_propagation_n(X, Y, vector_to_dictionary(thetaplus))                                   <span class="comment"># Step 3</span></div><div class="line">        <span class="comment">### END CODE HERE ###</span></div><div class="line">        </div><div class="line">        <span class="comment"># Compute J_minus[i]. Inputs: "parameters_values, epsilon". Output = "J_minus[i]".</span></div><div class="line">        <span class="comment">### START CODE HERE ### (approx. 3 lines)</span></div><div class="line">        thetaminus = np.copy(parameters_values)                                      <span class="comment"># Step 1</span></div><div class="line">        thetaminus[i][<span class="number">0</span>] = thetaminus[i][<span class="number">0</span>] - epsilon                                <span class="comment"># Step 2        </span></div><div class="line">        J_minus[i], _ = forward_propagation_n(X, Y, vector_to_dictionary(thetaminus))                                   <span class="comment"># Step 3</span></div><div class="line">        <span class="comment">### END CODE HERE ###</span></div><div class="line">        </div><div class="line">        <span class="comment"># Compute gradapprox[i]</span></div><div class="line">        <span class="comment">### START CODE HERE ### (approx. 1 line)</span></div><div class="line">        gradapprox[i] = (J_plus[i] - J_minus[i]) / (<span class="number">2</span> * epsilon)</div><div class="line">        <span class="comment">### END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="comment"># Compare gradapprox to backward propagation gradients by computing difference.</span></div><div class="line">    <span class="comment">### START CODE HERE ### (approx. 1 line)</span></div><div class="line">    numerator = np.linalg.norm(grad - gradapprox)                                           <span class="comment"># Step 1'</span></div><div class="line">    denominator = np.linalg.norm(grad) + np.linalg.norm(gradapprox)                                         <span class="comment"># Step 2'</span></div><div class="line">    difference = numerator / denominator                                          <span class="comment"># Step 3'</span></div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> difference &gt; <span class="number">2e-7</span>:</div><div class="line">        <span class="keyword">print</span> (<span class="string">"\033[93m"</span> + <span class="string">"There is a mistake in the backward propagation! difference = "</span> + str(difference) + <span class="string">"\033[0m"</span>)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="keyword">print</span> (<span class="string">"\033[92m"</span> + <span class="string">"Your backward propagation works perfectly fine! difference = "</span> + str(difference) + <span class="string">"\033[0m"</span>)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> difference</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">X, Y, parameters = gradient_check_n_test_case()</div><div class="line"></div><div class="line">cost, cache = forward_propagation_n(X, Y, parameters)</div><div class="line">gradients = backward_propagation_n(X, Y, cache)</div><div class="line">difference = gradient_check_n(parameters, gradients, X, Y)</div></pre></td></tr></table></figure>
<p><strong>Expected output</strong>:</p>
<pre><code>There is a mistake in the backward propagation!
    difference = 0.285093156781
</code></pre><p>It seems that there were errors in the <code>backward_propagation_n</code> code we gave you! Good that you’ve implemented the gradient check. Go back to <code>backward_propagation</code> and try to find/correct the errors <em>(Hint: check dW2 and db1)</em>. Rerun the gradient check when you think you’ve fixed it. Remember you’ll need to re-execute the cell defining <code>backward_propagation_n()</code> if you modify the code. </p>
<p>Can you get gradient check to declare your derivative computation correct? Even though this part of the assignment isn’t graded, we strongly urge you to try to find the bug and re-run gradient check until you’re convinced backprop is now correctly implemented. </p>
<p><strong>Note</strong> </p>
<ul>
<li>Gradient Checking is slow! Approximating the gradient with $\frac{\partial J}{\partial \theta} \approx  \frac{J(\theta + \varepsilon) - J(\theta - \varepsilon)}{2 \varepsilon}$ is computationally costly. For this reason, we don’t run gradient checking at every iteration during training. Just a few times to check if the gradient is correct. </li>
<li>Gradient Checking, at least as we’ve presented it, doesn’t work with dropout. You would usually run the gradient check algorithm without dropout to make sure your backprop is correct, then add dropout. </li>
</ul>
<p>Congrats, you can be confident that your deep learning model for fraud detection is working correctly! You can even use this to convince your CEO. :) </p>
<font color="blue">

**What you should remember from this notebook**:
- Gradient checking verifies closeness between the gradients from backpropagation and the numerical approximation of the gradient (computed using forward propagation).
- Gradient checking is slow, so we don't run it in every iteration of training. You would usually run it only to make sure your code is correct, then turn it off and use backprop for the actual learning process. 

</font>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/04/24/coursera中无法播放视频解决方法/" rel="next" title="coursera中无法播放视频解决方法">
                <i class="fa fa-chevron-left"></i> coursera中无法播放视频解决方法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/05/coursera-deeplearning-ai-c2-week2/" rel="prev" title="coursera-deeplearning-ai-c2-week2">
                coursera-deeplearning-ai-c2-week2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="hypercomments_widget"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/wukong.png"
               alt="张阿楠" />
          <p class="site-author-name" itemprop="name">张阿楠</p>
           
              <p class="site-description motion-element" itemprop="description">Keep codeing and thinking!</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">54</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">26</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/vernlium" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/ananzhang" target="_blank" title="ZhiHu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      ZhiHu
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#课程笔记"><span class="nav-number">1.</span> <span class="nav-text">课程笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Setting-up-your-Machine-Learning-Application"><span class="nav-number">1.1.</span> <span class="nav-text">Setting up your Machine Learning Application</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Train-Dev-Test-sets"><span class="nav-number">1.1.1.</span> <span class="nav-text">Train / Dev / Test sets</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bias-Variance"><span class="nav-number">1.1.2.</span> <span class="nav-text">Bias / Variance</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Basic-Recipe-for-Machine-Learning"><span class="nav-number">1.1.3.</span> <span class="nav-text">Basic Recipe for Machine Learning</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Regularizing-your-neural-network"><span class="nav-number">1.2.</span> <span class="nav-text">Regularizing your neural network</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Regularization-正则化"><span class="nav-number">1.2.1.</span> <span class="nav-text">Regularization(正则化)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#逻辑回归的正则化"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">逻辑回归的正则化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#神经网络的正则化"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">神经网络的正则化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Why-regularization-reduces-overfitting"><span class="nav-number">1.2.2.</span> <span class="nav-text">Why regularization reduces overfitting?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dropout-Regularization-随机失活正则化（丢弃法）"><span class="nav-number">1.2.3.</span> <span class="nav-text">Dropout Regularization(随机失活正则化（丢弃法）)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#dropout的实现："><span class="nav-number">1.2.3.1.</span> <span class="nav-text">dropout的实现：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Understanding-Dropout"><span class="nav-number">1.2.4.</span> <span class="nav-text">Understanding Dropout</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Other-regularization-methods"><span class="nav-number">1.2.5.</span> <span class="nav-text">Other regularization methods</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Setting-up-your-optimization-problem"><span class="nav-number">1.3.</span> <span class="nav-text">Setting up your optimization problem</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Normalizing-inputs"><span class="nav-number">1.3.1.</span> <span class="nav-text">Normalizing inputs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vanishing-Exploding-gradients"><span class="nav-number">1.3.2.</span> <span class="nav-text">Vanishing / Exploding gradients</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Weight-Initialization-for-Deep-Networks"><span class="nav-number">1.3.3.</span> <span class="nav-text">Weight Initialization for Deep Networks</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Gradient-checking"><span class="nav-number">1.3.4.</span> <span class="nav-text">Gradient checking</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Gradient-Checking-Implementation-Notes"><span class="nav-number">1.3.5.</span> <span class="nav-text">Gradient Checking Implementation Notes</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编程练习"><span class="nav-number">2.</span> <span class="nav-text">编程练习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Initialization"><span class="nav-number">2.1.</span> <span class="nav-text">Initialization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Regularization"><span class="nav-number">2.2.</span> <span class="nav-text">Regularization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gradient-Checking"><span class="nav-number">2.3.</span> <span class="nav-text">Gradient Checking</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-How-does-gradient-checking-work"><span class="nav-number">2.3.1.</span> <span class="nav-text">1) How does gradient checking work?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-dimensional-gradient-checking"><span class="nav-number">2.3.2.</span> <span class="nav-text">2) 1-dimensional gradient checking</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-N-dimensional-gradient-checking"><span class="nav-number">2.3.3.</span> <span class="nav-text">3) N-dimensional gradient checking</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张阿楠</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	

		<script type="text/javascript">
		_hcwp = window._hcwp || [];

		_hcwp.push({widget:"Bloggerstream", widget_id: 95829, selector:".hc-comment-count", label: "{\%COUNT%\}" });

		
		_hcwp.push({widget:"Stream", widget_id: 95829, xid: "2018/07/05/coursera-deeplearning-ai-c2-week1/"});
		

		(function() {
		if("HC_LOAD_INIT" in window)return;
		HC_LOAD_INIT = true;
		var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || "en").substr(0, 2).toLowerCase();
		var hcc = document.createElement("script"); hcc.type = "text/javascript"; hcc.async = true;
		hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://w.hypercomments.com/widget/hc/95829/"+lang+"/widget.js";
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(hcc, s.nextSibling);
		})();
		</script>

	










  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
