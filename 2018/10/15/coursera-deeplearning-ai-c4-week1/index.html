<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="课程笔记本周课程从边缘检测讲起，引出卷积的概念，并讲到了卷积中的padding、pooling等操作，要点：  边缘检测 卷积的实现 padding pooling stride  学习目标：  Understand the convolution operation Understand the pooling operation Remember the vocabulary used in">
<meta property="og:type" content="article">
<meta property="og:title" content="coursera-deeplearning-ai-c4-week1">
<meta property="og:url" content="://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/index.html">
<meta property="og:site_name" content="Vernlium">
<meta property="og:description" content="课程笔记本周课程从边缘检测讲起，引出卷积的概念，并讲到了卷积中的padding、pooling等操作，要点：  边缘检测 卷积的实现 padding pooling stride  学习目标：  Understand the convolution operation Understand the pooling operation Remember the vocabulary used in">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/vertical_edge_detection.jpg">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/vertical_and_horizontal_edge_detection.jpg">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/stride2.gif">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/summary_of_convolution.jpg">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/mulit_channel_convolution.gif">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/multiple_filters.jpg">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/summary_of_notation.jpg">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/example_convnet.jpg">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/maxpool_animation.gif">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/neural_network_example.jpg">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/lenet_5_parameters.jpg">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/putting_it_together.jpg">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/model.png">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/conv_nn.png">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/PAD.png">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/Convolution_schematic.gif">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/conv_kiank.gif">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/vert_horiz_kiank.png">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/max_pool1.png">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/a_pool.png">
<meta property="og:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/SIGNS.png">
<meta property="og:updated_time" content="2018-11-02T14:45:57.938Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="coursera-deeplearning-ai-c4-week1">
<meta name="twitter:description" content="课程笔记本周课程从边缘检测讲起，引出卷积的概念，并讲到了卷积中的padding、pooling等操作，要点：  边缘检测 卷积的实现 padding pooling stride  学习目标：  Understand the convolution operation Understand the pooling operation Remember the vocabulary used in">
<meta name="twitter:image" content="/2018/10/15/coursera-deeplearning-ai-c4-week1/vertical_edge_detection.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/"/>





  <title>coursera-deeplearning-ai-c4-week1 | Vernlium</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Vernlium</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Keep codeing and thinking!</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="://vernlium.github.io/2018/10/15/coursera-deeplearning-ai-c4-week1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张阿楠">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/wukong.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vernlium">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">coursera-deeplearning-ai-c4-week1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-15T07:16:40+08:00">
                2018-10-15
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/15/coursera-deeplearning-ai-c4-week1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2018/10/15/coursera-deeplearning-ai-c4-week1/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="课程笔记"><a href="#课程笔记" class="headerlink" title="课程笔记"></a>课程笔记</h2><p>本周课程从边缘检测讲起，引出卷积的概念，并讲到了卷积中的padding、pooling等操作，要点：</p>
<ul>
<li>边缘检测</li>
<li>卷积的实现</li>
<li>padding</li>
<li>pooling</li>
<li>stride</li>
</ul>
<p>学习目标：</p>
<ul>
<li>Understand the convolution operation</li>
<li>Understand the pooling operation</li>
<li>Remember the vocabulary used in convolutional neural network (padding, stride, filter, …)</li>
<li>Build a convolutional neural network for image multi-class classification</li>
</ul>
<h3 id="Convolutional-Neural-Networks"><a href="#Convolutional-Neural-Networks" class="headerlink" title="Convolutional Neural Networks"></a>Convolutional Neural Networks</h3><h4 id="Computer-Vision"><a href="#Computer-Vision" class="headerlink" title="Computer Vision"></a>Computer Vision</h4><p>计算机视觉的应用：</p>
<ul>
<li>Image Classification</li>
<li>Object detection</li>
<li>Image Style Transfer</li>
</ul>
<h4 id="Edge-Detection-Example"><a href="#Edge-Detection-Example" class="headerlink" title="Edge Detection Example"></a>Edge Detection Example</h4><p>通过特定的filter，可以检测出特定的边缘。比如，下图中的filter可以检测出垂直方向的边缘。</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/vertical_edge_detection.jpg" alt="Vertical Edge Detection" title="Vertical Edge Detection">
<h4 id="More-Edge-Detection"><a href="#More-Edge-Detection" class="headerlink" title="More Edge Detection"></a>More Edge Detection</h4><img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/vertical_and_horizontal_edge_detection.jpg" alt="Vertical and Horizontal Edge Detection" title="Vertical and Horizontal Edge Detection">
<p>在深度学习领域，要通过训练学习的方式，学习得到filter来检测不同的边缘。</p>
<h4 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h4><p>上面给的filter，会把结果图像的尺寸变小，所以通过padding操作，在输入图像边缘填充的方式，使得原图像变大，以保持输出尺寸和原图像大小一致。</p>
<p>输出图像的尺寸计算公式为：$ n - f +1 $</p>
<p>加入padding后，输出图像的尺寸计算公式为：$ n + 2p - f + 1 $</p>
<p>为了使输出图像尺寸保持不变，即$ n + 2p - f + 1 = n $，所以</p>
<script type="math/tex; mode=display">p = \frac{ f - 1 }{2}</script><p>有两种padding方式：</p>
<ul>
<li><strong>VALID</strong>: 不进行padding，输出图像的尺寸计算公式为：$ n - f +1 $</li>
<li><strong>SAME</strong>： 进行padding，大小为：<script type="math/tex">p = \frac{ f - 1 }{2}</script></li>
</ul>
<blockquote>
<p>注：深度学习领域，一般情况下f取值为奇数，比如1、3、5、7等。否则会出现不对称填充。</p>
</blockquote>
<p>Tensorflow中，VALID padding的实现如下：</p>
<script type="math/tex; mode=display">\text{padding along height} = P_h = max((\text{output height}-1)*S_h + F_h - H, 0)</script><script type="math/tex; mode=display">\text{padding along width} = P_w = max((\text{output width}-1)*S_w + F_w - W, 0)</script><script type="math/tex; mode=display">\text{padding top} = P_t = Floor(\dfrac{P_h}{2}) \qquad \qquad \text{padding left} = P_l = Floor(\dfrac{P_w}{2})</script><script type="math/tex; mode=display">\text{padding bottom} = P_h - P_t \qquad \qquad \text{padding right} = P_w - P_l</script><p>代码实现为：</p>
<p>For the ‘SAME’ padding, the output height and width are computed as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">out_height = ceil(float(in_height) / float(strides[1]))</div><div class="line">out_width  = ceil(float(in_width) / float(strides[2]))</div></pre></td></tr></table></figure>
<p>and the padding on the top and left are computed as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pad_along_height = max((out_height - 1) * strides[1] + filter_height - in_height, 0)</div><div class="line">pad_along_width = max((out_width - 1) * strides[2] + filter_width - in_width, 0)</div><div class="line">pad_top = pad_along_height // 2</div><div class="line">pad_bottom = pad_along_height - pad_top</div><div class="line">pad_left = pad_along_width // 2</div><div class="line">pad_right = pad_along_width - pad_left</div></pre></td></tr></table></figure>
<p>For the ‘VALID’ padding, the output height and width are computed as:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">out_height = ceil(float(in_height - filter_height + 1) / float(strides[1]))</div><div class="line">out_width  = ceil(float(in_width - filter_width + 1) / float(strides[2]))</div></pre></td></tr></table></figure>
<p>and the padding values are always zero.</p>
<h4 id="Strided-Convolutions"><a href="#Strided-Convolutions" class="headerlink" title="Strided Convolutions"></a>Strided Convolutions</h4><p>步长是卷积核进行计算是每次跳跃的长度。</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/stride2.gif" alt="Convolution with stride 2" title="Convolution with stride 2">
<script type="math/tex; mode=display">
\text{output width} = \dfrac{W-F_w+2P}{S_w}+1</script><script type="math/tex; mode=display">
\text{output height} = \dfrac{H-F_h+2P}{S_h}+1</script><img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/summary_of_convolution.jpg" alt="Summary of convolution" title="Summary of convolution">
<h4 id="Convolutions-Over-Volume"><a href="#Convolutions-Over-Volume" class="headerlink" title="Convolutions Over Volume"></a>Convolutions Over Volume</h4><p>上面讲的卷积是二维的，在正常卷积神经网络中，卷积一般是3维的，也就是多channel的，通过下图可以理解多channel卷积的计算。</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/mulit_channel_convolution.gif" alt="Multi-channel input convolution" title="Multi-channel input convolution">
<p>上图中，输入是一副图片，3个通道（RGB），filter也对应3个通道，计算后得到一个2维的结果。如果想要结果也是多维的，则需要多个fliter，如下图：</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/multiple_filters.jpg" alt="Multiple filters" title="Multiple filters">
<h4 id="One-Layer-of-a-Convolutional-Network"><a href="#One-Layer-of-a-Convolutional-Network" class="headerlink" title="One Layer of a Convolutional Network"></a>One Layer of a Convolutional Network</h4><p>卷积层和之前讲到的神经网络的典型计算公式是类似的。</p>
<p>下图是各种卷积层的概念的表达方式：</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/summary_of_notation.jpg" alt="Summary of notation" title="Summary of notation">
<h4 id="Simple-Convolutional-Network-Example"><a href="#Simple-Convolutional-Network-Example" class="headerlink" title="Simple Convolutional Network Example"></a>Simple Convolutional Network Example</h4><p>下图是一个典型卷积网络的例子：</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/example_convnet.jpg" alt="Example ConvNet" title="Example ConvNet">
<p>Types of layer in a convolutional network:</p>
<ul>
<li>Convolution</li>
<li>Pooling</li>
<li>Fully connected</li>
</ul>
<h4 id="Pooling-Layers"><a href="#Pooling-Layers" class="headerlink" title="Pooling Layers"></a>Pooling Layers</h4><img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/maxpool_animation.gif" alt="Maxpooling" title="Maxpooling">
<p>Max Pooling的一个有趣的特性是：它有一套超参，但是它没有任何参数需要学习。没有任何需要梯度相加算法学习的东西，一旦确定了$ f $和$ s $就确定了计算,而且梯度下降算法不会对其有任何改变。</p>
<p>上面卷积层计算输出size的公式同样在这里适用。</p>
<p>还有一种是Average Pooling，就是求filter*filter内的平均值。相比来说，Max Pooling用的更多。</p>
<p>Pooling层的超参数有如下三个：</p>
<ul>
<li>f : filter size</li>
<li>s : stride</li>
<li>Max or average pooling</li>
</ul>
<p>不需要通过学习即可确定。</p>
<h4 id="CNN-Example"><a href="#CNN-Example" class="headerlink" title="CNN Example"></a>CNN Example</h4><p>下图是一个卷积神经网络的示例，是基于LeNet-5网络改造的。</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/neural_network_example.jpg" alt="Neural Network Example" title="Neural Network Example">
<blockquote>
<p>注： LeNet-5网络是Yann LeCun在1998年设计的用于手写数字识别的卷积神经网络,当年美国大多数银行就是用它来识别支票上面的手写数字的,它是早期卷积神经网络中最有代表性的实验系统之一。可参考：<a href="http://yann.lecun.com/exdb/lenet/" target="_blank" rel="external">http://yann.lecun.com/exdb/lenet/</a><br>LeNet-5的数据集是MNIST，一般也是各种深度学习框架的入门示例，学习起来很好理解，也很简单，作为入门的示例非常好。<br>这个网站<a href="http://scs.ryerson.ca/~aharley/vis/conv/" target="_blank" rel="external">http://scs.ryerson.ca/~aharley/vis/conv/</a>做了一个3D展示LeNet-5网络每一层的效果，看起来很清晰，推荐。</p>
</blockquote>
<p>下图是上面的LeNet-5网络的每一层的参数个数表，可以看出，卷积层的参数相比于全连接层是非常少的，这也是卷积层的优势所在。</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/lenet_5_parameters.jpg" alt="LeNet-5 Parameters" title="LeNet-5 Parameters">
<p>关于超参数组选择的建议：</p>
<p>不要试着创造你自己的超参数组，而是查看文献，看看其他人使用的超参数，从中选一组适用于其他人的超参数，很可能它也适用于你的应用。</p>
<p>通常随着神经网络的深入，高度$n_h$和宽度$n_w$会减小。然而通道数量会增加，最后是全连通网络层。另一类常见的神经网络模型是，一个或多个卷积层接着一层池化层，再接着一个或多个卷积层叠加一层池化层，然后叠加几层全连接，也许最后还叠加一个Softmax层。</p>
<h4 id="Why-Convolutions"><a href="#Why-Convolutions" class="headerlink" title="Why Convolutions?"></a>Why Convolutions?</h4><p>卷积网络有效的原因：</p>
<ul>
<li><strong>Parameter sharing</strong>（参数共享）: A feature detector (such as a vertical edge detector) that’s useful in one part of the image is probably useful in another part of the image.</li>
<li><strong>Sparsity of connections</strong>(稀疏式联系): In each layer, each output value depends only on a small number of inputs.</li>
</ul>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/putting_it_together.jpg" alt="Putting it together" title="Putting it together">
<h2 id="编程练习"><a href="#编程练习" class="headerlink" title="编程练习"></a>编程练习</h2><h3 id="Convolutional-Neural-Networks-Step-by-Step"><a href="#Convolutional-Neural-Networks-Step-by-Step" class="headerlink" title="Convolutional Neural Networks: Step by Step"></a>Convolutional Neural Networks: Step by Step</h3><p>Welcome to Course 4’s first assignment! In this assignment, you will implement convolutional (CONV) and pooling (POOL) layers in numpy, including both forward propagation and (optionally) backward propagation. </p>
<p><strong>Notation</strong>:</p>
<ul>
<li>Superscript $[l]$ denotes an object of the $l^{th}$ layer. <ul>
<li>Example: $a^{[4]}$ is the $4^{th}$ layer activation. $W^{[5]}$ and $b^{[5]}$ are the $5^{th}$ layer parameters.</li>
</ul>
</li>
</ul>
<ul>
<li>Superscript $(i)$ denotes an object from the $i^{th}$ example. <ul>
<li>Example: $x^{(i)}$ is the $i^{th}$ training example input.</li>
</ul>
</li>
</ul>
<ul>
<li>Lowerscript $i$ denotes the $i^{th}$ entry of a vector.<ul>
<li>Example: $a^{[l]}_i$ denotes the $i^{th}$ entry of the activations in layer $l$, assuming this is a fully connected (FC) layer.</li>
</ul>
</li>
</ul>
<ul>
<li>$n_H$, $n_W$ and $n_C$ denote respectively the height, width and number of channels of a given layer. If you want to reference a specific layer $l$, you can also write $n_H^{[l]}$, $n_W^{[l]}$, $n_C^{[l]}$. </li>
<li>$n<em>{H</em>{prev}}$, $n<em>{W</em>{prev}}$ and $n<em>{C</em>{prev}}$ denote respectively the height, width and number of channels of the previous layer. If referencing a specific layer $l$, this could also be denoted $n_H^{[l-1]}$, $n_W^{[l-1]}$, $n_C^{[l-1]}$. </li>
</ul>
<p>We assume that you are already familiar with <code>numpy</code> and/or have completed the previous courses of the specialization. Let’s get started!</p>
<h4 id="1-Packages"><a href="#1-Packages" class="headerlink" title="1 - Packages"></a>1 - Packages</h4><p>Let’s first import all the packages that you will need during this assignment. </p>
<ul>
<li><a href="www.numpy.org">numpy</a> is the fundamental package for scientific computing with Python.</li>
<li><a href="http://matplotlib.org" target="_blank" rel="external">matplotlib</a> is a library to plot graphs in Python.</li>
<li>np.random.seed(1) is used to keep all the random function calls consistent. It will help us grade your work.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> h5py</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"></div><div class="line">get_ipython().run_line_magic(<span class="string">'matplotlib'</span>, <span class="string">'inline'</span>)</div><div class="line">plt.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">5.0</span>, <span class="number">4.0</span>) set default size of plots</div><div class="line">plt.rcParams[<span class="string">'image.interpolation'</span>] = <span class="string">'nearest'</span></div><div class="line">plt.rcParams[<span class="string">'image.cmap'</span>] = <span class="string">'gray'</span></div><div class="line"></div><div class="line">get_ipython().run_line_magic(<span class="string">'load_ext'</span>, <span class="string">'autoreload'</span>)</div><div class="line">get_ipython().run_line_magic(<span class="string">'autoreload'</span>, <span class="string">'2'</span>)</div><div class="line"></div><div class="line">np.random.seed(<span class="number">1</span>)</div></pre></td></tr></table></figure>
<h4 id="2-Outline-of-the-Assignment"><a href="#2-Outline-of-the-Assignment" class="headerlink" title="2 - Outline of the Assignment"></a>2 - Outline of the Assignment</h4><p>You will be implementing the building blocks of a convolutional neural network! Each function you will implement will have detailed instructions that will walk you through the steps needed:</p>
<ul>
<li>Convolution functions, including:<ul>
<li>Zero Padding</li>
<li>Convolve window </li>
<li>Convolution forward</li>
<li>Convolution backward (optional)</li>
</ul>
</li>
<li>Pooling functions, including:<ul>
<li>Pooling forward</li>
<li>Create mask </li>
<li>Distribute value</li>
<li>Pooling backward (optional)</li>
</ul>
</li>
</ul>
<p>This notebook will ask you to implement these functions from scratch in <code>numpy</code>. In the next notebook, you will use the TensorFlow equivalents of these functions to build the following model:</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/model.png" alt="Modle" title="Modle">
<p><strong>Note</strong> that for every forward function, there is its corresponding backward equivalent. Hence, at every step of your forward module you will store some parameters in a cache. These parameters are used to compute gradients during backpropagation. </p>
<h4 id="3-Convolutional-Neural-Networks"><a href="#3-Convolutional-Neural-Networks" class="headerlink" title="3 - Convolutional Neural Networks"></a>3 - Convolutional Neural Networks</h4><p>Although programming frameworks make convolutions easy to use, they remain one of the hardest concepts to understand in Deep Learning. A convolution layer transforms an input volume into an output volume of different size, as shown below. </p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/conv_nn.png" alt="Conv NN" title="Conv NN">
<p>In this part, you will build every step of the convolution layer. You will first implement two helper functions: one for zero padding and the other for computing the convolution function itself. </p>
<h5 id="3-1-Zero-Padding"><a href="#3-1-Zero-Padding" class="headerlink" title="3.1 - Zero-Padding"></a>3.1 - Zero-Padding</h5><p>Zero-padding adds zeros around the border of an image:</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/PAD.png" alt="Zero-Padding Image (3 channels, RGB) with a padding of 2." title="Zero-Padding Image (3 channels, RGB) with a padding of 2.">
<p>The main benefits of padding are the following:</p>
<ul>
<li><p>It allows you to use a CONV layer without necessarily shrinking the height and width of the volumes. This is important for building deeper networks, since otherwise the height/width would shrink as you go to deeper layers. An important special case is the “same” convolution, in which the height/width is exactly preserved after one layer. </p>
</li>
<li><p>It helps us keep more of the information at the border of an image. Without padding, very few values at the next layer would be affected by pixels as the edges of an image.</p>
</li>
</ul>
<p><strong>Exercise</strong>: Implement the following function, which pads all the images of a batch of examples X with zeros. <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.pad.html" target="_blank" rel="external">Use np.pad</a>. Note if you want to pad the array “a” of shape $(5,5,5,5,5)$ with <code>pad = 1</code> for the 2nd dimension, <code>pad = 3</code> for the 4th dimension and <code>pad = 0</code> for the rest, you would do:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = np.pad(a, ((<span class="number">0</span>,<span class="number">0</span>), (<span class="number">1</span>,<span class="number">1</span>), (<span class="number">0</span>,<span class="number">0</span>), (<span class="number">3</span>,<span class="number">3</span>), (<span class="number">0</span>,<span class="number">0</span>)), <span class="string">'constant'</span>, constant_values = (..,..))</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#RADED FUNCTION: zero_pad</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">zero_pad</span><span class="params">(X, pad)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Pad with zeros all images of the dataset X. The padding is applied to the height and width of an image, </span></div><div class="line"><span class="string">    as illustrated in Figure 1.</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Argument:</span></div><div class="line"><span class="string">    X -- python numpy array of shape (m, n_H, n_W, n_C) representing a batch of m images</span></div><div class="line"><span class="string">    pad -- integer, amount of padding around each image on vertical and horizontal dimensions</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    X_pad -- padded image of shape (m, n_H + 2*pad, n_W + 2*pad, n_C)</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    <span class="comment">##START CODE HERE ##(≈ 1 line)</span></div><div class="line">    X_pad = np.pad(X, ((<span class="number">0</span>,<span class="number">0</span>),(pad,pad),(pad,pad),(<span class="number">0</span>,<span class="number">0</span>)), <span class="string">'constant'</span>)</div><div class="line">    <span class="comment">##END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> X_pad</div></pre></td></tr></table></figure>
<h5 id="3-2-Single-step-of-convolution"><a href="#3-2-Single-step-of-convolution" class="headerlink" title="3.2 - Single step of convolution"></a>3.2 - Single step of convolution</h5><p>In this part, implement a single step of convolution, in which you apply the filter to a single position of the input. This will be used to build a convolutional unit, which: </p>
<ul>
<li>Takes an input volume </li>
<li>Applies a filter at every position of the input</li>
<li>Outputs another volume (usually of different size)</li>
</ul>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/Convolution_schematic.gif" alt="Convolution operation with a filter of 2x2 and a stride of 1 (stride = amount you move the window each time you slide)" title="Convolution operation with a filter of 2x2 and a stride of 1 (stride = amount you move the window each time you slide)">
<p>In a computer vision application, each value in the matrix on the left corresponds to a single pixel value, and we convolve a 3x3 filter with the image by multiplying its values element-wise with the original matrix, then summing them up and adding a bias. In this first step of the exercise, you will implement a single step of convolution, corresponding to applying a filter to just one of the positions to get a single real-valued output. </p>
<p>Later in this notebook, you’ll apply this function to multiple positions of the input to implement the full convolutional operation. </p>
<p><strong>Exercise</strong>: Implement conv_single_step(). <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.sum.html" target="_blank" rel="external">Hint</a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># GRADED FUNCTION: conv_single_step</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_single_step</span><span class="params">(a_slice_prev, W, b)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Apply one filter defined by parameters W on a single slice (a_slice_prev) of the output activation </span></div><div class="line"><span class="string">    of the previous layer.</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    a_slice_prev -- slice of input data of shape (f, f, n_C_prev)</span></div><div class="line"><span class="string">    W -- Weight parameters contained in a window - matrix of shape (f, f, n_C_prev)</span></div><div class="line"><span class="string">    b -- Bias parameters contained in a window - matrix of shape (1, 1, 1)</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    Z -- a scalar value, result of convolving the sliding window (W, b) on a slice x of the input data</span></div><div class="line"><span class="string">    """</span></div><div class="line"></div><div class="line">    <span class="comment">##START CODE HERE ##(≈ 2 lines of code)</span></div><div class="line">    Element-wise product between a_slice <span class="keyword">and</span> W. Do <span class="keyword">not</span> add the bias yet.</div><div class="line">    s = a_slice_prev * W</div><div class="line">    Sum over all entries of the volume s.</div><div class="line">    Z = np.sum(s)</div><div class="line">    Add bias b to Z. Cast b to a float() so that Z results <span class="keyword">in</span> a scalar value.</div><div class="line">    Z = Z + float(b)</div><div class="line">    <span class="comment">##END CODE HERE ###</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> Z</div></pre></td></tr></table></figure>
<h5 id="3-3-Convolutional-Neural-Networks-Forward-pass"><a href="#3-3-Convolutional-Neural-Networks-Forward-pass" class="headerlink" title="3.3 - Convolutional Neural Networks - Forward pass"></a>3.3 - Convolutional Neural Networks - Forward pass</h5><p>In the forward pass, you will take many filters and convolve them on the input. Each ‘convolution’ gives you a 2D matrix output. You will then stack these outputs to get a 3D volume: </p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/conv_kiank.gif" alt="Conv Kiank" title="Conv Kiank">
<p><strong>Exercise</strong>: Implement the function below to convolve the filters W on an input activation A_prev. This function takes as input A_prev, the activations output by the previous layer (for a batch of m inputs), F filters/weights denoted by W, and a bias vector denoted by b, where each filter has its own (single) bias. Finally you also have access to the hyperparameters dictionary which contains the stride and the padding. </p>
<p><strong>Hint</strong>: </p>
<ol>
<li>To select a 2x2 slice at the upper left corner of a matrix “a_prev” (shape (5,5,3)), you would do:<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a_slice_prev = a_prev[<span class="number">0</span>:<span class="number">2</span>,<span class="number">0</span>:<span class="number">2</span>,:]</div></pre></td></tr></table></figure>
</li>
</ol>
<p>This will be useful when you will define <code>a_slice_prev</code> below, using the <code>start/end</code> indexes you will define.</p>
<ol>
<li>To define a_slice you will need to first define its corners <code>vert_start</code>, <code>vert_end</code>, <code>horiz_start</code> and <code>horiz_end</code>. This figure may be helpful for you to find how each of the corner can be defined using h, w, f and s in the code below.</li>
</ol>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/vert_horiz_kiank.png" alt="Definition of a slice using vertical and horizontal start/end (with a 2x2 filter). This figure shows only a single channel" title="Definition of a slice using vertical and horizontal start/end (with a 2x2 filter). This figure shows only a single channel">
<p><strong>Reminder</strong>:<br>The formulas relating the output shape of the convolution to the input shape is:</p>
<script type="math/tex; mode=display">n_H = \lfloor \frac{n_{H_{prev}} - f + 2 \times pad}{stride} \rfloor +1</script><script type="math/tex; mode=display">n_W = \lfloor \frac{n_{W_{prev}} - f + 2 \times pad}{stride} \rfloor +1</script><script type="math/tex; mode=display">n_C = \text{number of filters used in the convolution}</script><p>For this exercise, we won’t worry about vectorization, and will just implement everything with for-loops.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># GRADED FUNCTION: conv_forward</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_forward</span><span class="params">(A_prev, W, b, hparameters)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Implements the forward propagation for a convolution function</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    A_prev -- output activations of the previous layer, numpy array of shape (m, n_H_prev, n_W_prev, n_C_prev)</span></div><div class="line"><span class="string">    W -- Weights, numpy array of shape (f, f, n_C_prev, n_C)</span></div><div class="line"><span class="string">    b -- Biases, numpy array of shape (1, 1, 1, n_C)</span></div><div class="line"><span class="string">    hparameters -- python dictionary containing "stride" and "pad"</span></div><div class="line"><span class="string">        </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    Z -- conv output, numpy array of shape (m, n_H, n_W, n_C)</span></div><div class="line"><span class="string">    cache -- cache of values needed for the conv_backward() function</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    <span class="comment">##START CODE HERE ###</span></div><div class="line">    <span class="comment"># Retrieve dimensions from A_prev's shape (≈1 line)  </span></div><div class="line">    (m, n_H_prev, n_W_prev, n_C_prev) = A_prev.shape</div><div class="line">    </div><div class="line">    <span class="comment"># Retrieve dimensions from W's shape (≈1 line)</span></div><div class="line">    (f, f, n_C_prev, n_C) = W.shape</div><div class="line">    </div><div class="line">    <span class="comment"># Retrieve information from "hparameters" (≈2 lines)</span></div><div class="line">    stride = hparameters[<span class="string">'stride'</span>]</div><div class="line">    pad = hparameters[<span class="string">'pad'</span>]</div><div class="line">    </div><div class="line">    <span class="comment"># Compute the dimensions of the CONV output volume using the formula given above. Hint: use int() to floor. (≈2 lines)</span></div><div class="line">    n_H = int((n_H_prev+<span class="number">2</span>*pad-f)/stride+<span class="number">1</span>)</div><div class="line">    n_W = int((n_W_prev+<span class="number">2</span>*pad-f)/stride+<span class="number">1</span>)</div><div class="line">    </div><div class="line">    <span class="comment"># Initialize the output volume Z with zeros. (≈1 line)</span></div><div class="line">    Z = np.zeros((m, n_H, n_W, n_C))</div><div class="line">    </div><div class="line">    <span class="comment"># Create A_prev_pad by padding A_prev</span></div><div class="line">    A_prev_pad = zero_pad(A_prev, pad)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):                              <span class="comment"># loop over the batch of training examples</span></div><div class="line">        a_prev_pad = A_prev_pad[i,:]                <span class="comment"># Select ith training example's padded activation</span></div><div class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(n_H):                          <span class="comment"># loop over vertical axis of the output volume</span></div><div class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> range(n_W):                      <span class="comment"># loop over horizontal axis of the output volume</span></div><div class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> range(n_C):                  <span class="comment"># loop over channels (= #filters) of the output volume</span></div><div class="line">                    </div><div class="line">                    <span class="comment"># Find the corners of the current "slice" (≈4 lines)</span></div><div class="line">                    <span class="comment"># Note: there is a stride, therefore it is not wise to assign vert_start a value of h and it is the same with horiz_start</span></div><div class="line">                    vert_start = h * stride</div><div class="line">                    vert_end = vert_start + f</div><div class="line">                    horiz_start = w * stride</div><div class="line">                    horiz_end = horiz_start + f</div><div class="line">                    </div><div class="line">                    <span class="comment"># Use the corners to define the (3D) slice of a_prev_pad (See Hint above the cell). (≈1 line)</span></div><div class="line">                    a_slice_prev = a_prev_pad[vert_start:vert_end, horiz_start:horiz_end, :]</div><div class="line">                    </div><div class="line">                    <span class="comment"># Convolve the (3D) slice with the correct filter W and bias b, to get back one output neuron. (≈1 line)</span></div><div class="line">                    Z[i, h, w, c] = np.sum(a_slice_prev * W[:, :, :, c]) + float(b[:, :, :, c])</div><div class="line">                    Z[i, h, w, c] = conv_single_step(a_slice_prev, W[:, :, :, c], b[:, :, :, c])</div><div class="line">                                        </div><div class="line">    <span class="comment">##END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="comment"># Making sure your output shape is correct</span></div><div class="line">    <span class="keyword">assert</span>(Z.shape == (m, n_H, n_W, n_C))</div><div class="line">    </div><div class="line">    <span class="comment"># Save information in "cache" for the backprop</span></div><div class="line">    cache = (A_prev, W, b, hparameters)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> Z, cache</div></pre></td></tr></table></figure>
<p>Finally, CONV layer should also contain an activation, in which case we would add the following line of code:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Convolve the window to get back one output neuron</span></div><div class="line">Z[i, h, w, c] = ...</div><div class="line"><span class="comment"># Apply activation</span></div><div class="line">A[i, h, w, c] = activation(Z[i, h, w, c])</div></pre></td></tr></table></figure>
<p>You don’t need to do it here. </p>
<h4 id="4-Pooling-layer"><a href="#4-Pooling-layer" class="headerlink" title="4 - Pooling layer"></a>4 - Pooling layer</h4><p>The pooling (POOL) layer reduces the height and width of the input. It helps reduce computation, as well as helps make feature detectors more invariant to its position in the input. The two types of pooling layers are: </p>
<ul>
<li><p>Max-pooling layer: slides an ($f, f$) window over the input and stores the max value of the window in the output.</p>
</li>
<li><p>Average-pooling layer: slides an ($f, f$) window over the input and stores the average value of the window in the output.</p>
</li>
</ul>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/max_pool1.png" alt="Max Pooling" title="Max Pooling">
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/a_pool.png" alt="Average Pooling" title="Average Pooling">
<p>These pooling layers have no parameters for backpropagation to train. However, they have hyperparameters such as the window size $f$. This specifies the height and width of the fxf window you would compute a max or average over. </p>
<h5 id="4-1-Forward-Pooling"><a href="#4-1-Forward-Pooling" class="headerlink" title="4.1 - Forward Pooling"></a>4.1 - Forward Pooling</h5><p>Now, you are going to implement MAX-POOL and AVG-POOL, in the same function. </p>
<p><strong>Exercise</strong>: Implement the forward pass of the pooling layer. Follow the hints in the comments below.</p>
<p><strong>Reminder</strong>:<br>As there’s no padding, the formulas binding the output shape of the pooling to the input shape is:</p>
<script type="math/tex; mode=display">n_H = \lfloor \frac{n_{H_{prev}} - f}{stride} \rfloor +1</script><script type="math/tex; mode=display">n_W = \lfloor \frac{n_{W_{prev}} - f}{stride} \rfloor +1</script><script type="math/tex; mode=display">n_C = n_{C_{prev}}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#GRADED FUNCTION: pool_forward</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pool_forward</span><span class="params">(A_prev, hparameters, mode = <span class="string">"max"</span>)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Implements the forward pass of the pooling layer</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    A_prev -- Input data, numpy array of shape (m, n_H_prev, n_W_prev, n_C_prev)</span></div><div class="line"><span class="string">    hparameters -- python dictionary containing "f" and "stride"</span></div><div class="line"><span class="string">    mode -- the pooling mode you would like to use, defined as a string ("max" or "average")</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    A -- output of the pool layer, a numpy array of shape (m, n_H, n_W, n_C)</span></div><div class="line"><span class="string">    cache -- cache used in the backward pass of the pooling layer, contains the input and hparameters </span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    <span class="comment"># Retrieve dimensions from the input shape</span></div><div class="line">    (m, n_H_prev, n_W_prev, n_C_prev) = A_prev.shape</div><div class="line">    </div><div class="line">    <span class="comment"># Retrieve hyperparameters from "hparameters"</span></div><div class="line">    f = hparameters[<span class="string">"f"</span>]</div><div class="line">    stride = hparameters[<span class="string">"stride"</span>]</div><div class="line">    </div><div class="line">    <span class="comment"># Define the dimensions of the output</span></div><div class="line">    n_H = int(<span class="number">1</span> + (n_H_prev - f) / stride)</div><div class="line">    n_W = int(<span class="number">1</span> + (n_W_prev - f) / stride)</div><div class="line">    n_C = n_C_prev</div><div class="line">    </div><div class="line">    <span class="comment"># Initialize output matrix A</span></div><div class="line">    A = np.zeros((m, n_H, n_W, n_C))              </div><div class="line">    </div><div class="line">    <span class="comment">##START CODE HERE ###</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):                          <span class="comment"># loop over the training examples</span></div><div class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(n_H):                    <span class="comment"># loop on the vertical axis of the output volume</span></div><div class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> range(n_W):                <span class="comment"># loop on the horizontal axis of the output volume</span></div><div class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> range (n_C):           <span class="comment"># loop over the channels of the output volume</span></div><div class="line">                    </div><div class="line">                    <span class="comment"># Find the corners of the current "slice" (≈4 lines)</span></div><div class="line">                    vert_start = h*stride</div><div class="line">                    vert_end = vert_start+f</div><div class="line">                    horiz_start = w*stride</div><div class="line">                    horiz_end = horiz_start+f</div><div class="line">                    </div><div class="line">                    <span class="comment"># Use the corners to define the current slice on the ith training example of A_prev, channel c. (≈1 line)</span></div><div class="line">                    a_prev_slice = A_prev[i, vert_start:vert_end, horiz_start:horiz_end, c]</div><div class="line">                    </div><div class="line">                    <span class="comment"># Compute the pooling operation on the slice. Use an if statment to differentiate the modes. Use np.max/np.mean.</span></div><div class="line">                    <span class="keyword">if</span> mode == <span class="string">"max"</span>:</div><div class="line">                        A[i, h, w, c] = np.max(a_prev_slice)</div><div class="line">                    <span class="keyword">elif</span> mode == <span class="string">"average"</span>:</div><div class="line">                        A[i, h, w, c] = np.sum(a_prev_slice)/(f*f)</div><div class="line">    </div><div class="line">    <span class="comment">##END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="comment"># Store the input and hparameters in "cache" for pool_backward()</span></div><div class="line">    cache = (A_prev, hparameters)</div><div class="line">    </div><div class="line">    <span class="comment"># Making sure your output shape is correct</span></div><div class="line">    <span class="keyword">assert</span>(A.shape == (m, n_H, n_W, n_C))</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> A, cache</div></pre></td></tr></table></figure>
<p>Congratulations! You have now implemented the forward passes of all the layers of a convolutional network. </p>
<p>The remainer of this notebook is optional, and will not be graded.</p>
<h4 id="5-Backpropagation-in-convolutional-neural-networks-OPTIONAL-UNGRADED"><a href="#5-Backpropagation-in-convolutional-neural-networks-OPTIONAL-UNGRADED" class="headerlink" title="5 - Backpropagation in convolutional neural networks (OPTIONAL / UNGRADED)"></a>5 - Backpropagation in convolutional neural networks (OPTIONAL / UNGRADED)</h4><p>In modern deep learning frameworks, you only have to implement the forward pass, and the framework takes care of the backward pass, so most deep learning engineers don’t need to bother with the details of the backward pass. The backward pass for convolutional networks is complicated. If you wish however, you can work through this optional portion of the notebook to get a sense of what backprop in a convolutional network looks like. </p>
<p>When in an earlier course you implemented a simple (fully connected) neural network, you used backpropagation to compute the derivatives with respect to the cost to update the parameters. Similarly, in convolutional neural networks you can to calculate the derivatives with respect to the cost in order to update the parameters. The backprop equations are not trivial and we did not derive them in lecture, but we briefly presented them below.</p>
<h5 id="5-1-Convolutional-layer-backward-pass"><a href="#5-1-Convolutional-layer-backward-pass" class="headerlink" title="5.1 - Convolutional layer backward pass"></a>5.1 - Convolutional layer backward pass</h5><p>Let’s start by implementing the backward pass for a CONV layer. </p>
<h6 id="5-1-1-Computing-dA"><a href="#5-1-1-Computing-dA" class="headerlink" title="5.1.1 - Computing dA"></a>5.1.1 - Computing dA</h6><p>This is the formula for computing $dA$ with respect to the cost for a certain filter $W_c$ and a given training example:</p>
<script type="math/tex; mode=display">dA += \sum _{h=0} ^{n_H} \sum_{w=0} ^{n_W} W_c \times dZ_{hw}</script><p>Where $W<em>c$  is a filter and $dZ</em>{hw}$ is a scalar corresponding to the gradient of the cost with respect to the output of the conv layer $Z$ at the $h^{th}$ row and wth column (corresponding to the dot product taken at the ith stride left and jth stride down). Note that at each time, we multiply the the same filter $W_c$ by a different dZ when updating $dA$. We do so mainly because when computing the forward propagation, each filter is dotted and summed by a different a_slice. Therefore when computing the backprop for $dA$, we are just adding the gradients of all the a_slices. </p>
<p>In code, inside the appropriate for-loops, this formula translates into:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">da_prev_pad[vert_start:vert_end, horiz_start:horiz_end, :] += W[:,:,:,c] * dZ[i, h, w, c]</div></pre></td></tr></table></figure>
<h5 id="5-1-2-Computing-dW"><a href="#5-1-2-Computing-dW" class="headerlink" title="5.1.2 - Computing dW"></a>5.1.2 - Computing dW</h5><p>This is the formula for computing $dW_c$ ($dW_c$ is the derivative of one filter) with respect to the loss:</p>
<script type="math/tex; mode=display">dW_c  += \sum _{h=0} ^{n_H} \sum_{w=0} ^ {n_W} a_{slice} \times dZ_{hw}</script><p>Where $ a<em>{slice} $ corresponds to the slice which was used to generate the acitivation $ Z</em>{ij} $. Hence, this ends up giving us the gradient for $ W $ with respect to that slice. Since it is the same $ W $, we will just add up all such gradients to get $ dW $. </p>
<p>In code, inside the appropriate for-loops, this formula translates into:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dW[:,:,:,c] += a_slice * dZ[i, h, w, c]</div></pre></td></tr></table></figure></p>
<h6 id="5-1-3-Computing-db"><a href="#5-1-3-Computing-db" class="headerlink" title="5.1.3 - Computing db"></a>5.1.3 - Computing db</h6><p>This is the formula for computing $db$ with respect to the cost for a certain filter $W_c$:</p>
<script type="math/tex; mode=display">db = \sum_h \sum_w dZ_{hw}</script><p>As you have previously seen in basic neural networks, db is computed by summing $dZ$. In this case, you are just summing over all the gradients of the conv output (Z) with respect to the cost. </p>
<p>In code, inside the appropriate for-loops, this formula translates into:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db[:,:,:,c] += dZ[i, h, w, c]</div></pre></td></tr></table></figure></p>
<p><strong>Exercise</strong>: Implement the <code>conv_backward</code> function below. You should sum over all the training examples, filters, heights, and widths. You should then compute the derivatives using formulas 1, 2 and 3 above. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">conv_backward</span><span class="params">(dZ, cache)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Implement the backward propagation for a convolution function</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    dZ -- gradient of the cost with respect to the output of the conv layer (Z), numpy array of shape (m, n_H, n_W, n_C)</span></div><div class="line"><span class="string">    cache -- cache of values needed for the conv_backward(), output of conv_forward()</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    dA_prev -- gradient of the cost with respect to the input of the conv layer (A_prev),</span></div><div class="line"><span class="string">               numpy array of shape (m, n_H_prev, n_W_prev, n_C_prev)</span></div><div class="line"><span class="string">    dW -- gradient of the cost with respect to the weights of the conv layer (W)</span></div><div class="line"><span class="string">          numpy array of shape (f, f, n_C_prev, n_C)</span></div><div class="line"><span class="string">    db -- gradient of the cost with respect to the biases of the conv layer (b)</span></div><div class="line"><span class="string">          numpy array of shape (1, 1, 1, n_C)</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    <span class="comment">##START CODE HERE ###</span></div><div class="line">    <span class="comment"># Retrieve information from "cache"</span></div><div class="line">    (A_prev, W, b, hparameters) = cache</div><div class="line">    </div><div class="line">    <span class="comment"># Retrieve dimensions from A_prev's shape</span></div><div class="line">    (m, n_H_prev, n_W_prev, n_C_prev) = A_prev.shape</div><div class="line">    </div><div class="line">    <span class="comment"># Retrieve dimensions from W's shape</span></div><div class="line">    (f, f, n_C_prev, n_C) = W.shape</div><div class="line">    </div><div class="line">    <span class="comment"># Retrieve information from "hparameters"</span></div><div class="line">    stride = hparameters[<span class="string">'stride'</span>]</div><div class="line">    pad = hparameters[<span class="string">'pad'</span>]</div><div class="line">    </div><div class="line">    <span class="comment"># Retrieve dimensions from dZ's shape</span></div><div class="line">    (m, n_H, n_W, n_C) = dZ.shape</div><div class="line">    </div><div class="line">    <span class="comment"># Initialize dA_prev, dW, db with the correct shapes</span></div><div class="line">    dA_prev = np.zeros((m, n_H_prev, n_W_prev, n_C_prev))                           </div><div class="line">    dW = np.zeros((f, f, n_C_prev, n_C))</div><div class="line">    db = np.zeros((<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, n_C))</div><div class="line"></div><div class="line">    <span class="comment"># Pad A_prev and dA_prev</span></div><div class="line">    A_prev_pad = zero_pad(A_prev, pad)</div><div class="line">    dA_prev_pad = zero_pad(dA_prev, pad)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):                      <span class="comment"># loop over the training examples</span></div><div class="line">        </div><div class="line">        <span class="comment"># select ith training example from A_prev_pad and dA_prev_pad</span></div><div class="line">        a_prev_pad = A_prev_pad[i, :]</div><div class="line">        da_prev_pad = dA_prev_pad[i, :]</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(n_H):                   <span class="comment"># loop over vertical axis of the output volume</span></div><div class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> range(n_W):               <span class="comment"># loop over horizontal axis of the output volume</span></div><div class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> range(n_C):           <span class="comment"># loop over the channels of the output volume</span></div><div class="line">                    </div><div class="line">                    <span class="comment"># Find the corners of the current "slice"</span></div><div class="line">                    vert_start = h*stride</div><div class="line">                    vert_end = vert_start+f</div><div class="line">                    horiz_start = w*stride</div><div class="line">                    horiz_end = horiz_start+f</div><div class="line">                    </div><div class="line">                    <span class="comment"># Use the corners to define the slice from a_prev_pad</span></div><div class="line">                    a_slice = a_prev_pad[vert_start:vert_end, horiz_start:horiz_end, :]</div><div class="line"></div><div class="line">                    <span class="comment"># Update gradients for the window and the filter's parameters using the code formulas given above</span></div><div class="line">                    da_prev_pad[vert_start:vert_end, horiz_start:horiz_end, :] += W[:,:,:,c] * dZ[i, h, w, c]</div><div class="line">                    dW[:,:,:,c] += a_slice * dZ[i, h, w, c]</div><div class="line">                    db[:,:,:,c] += dZ[i, h, w, c]</div><div class="line">                    </div><div class="line">        <span class="comment"># Set the ith training example's dA_prev to the unpaded da_prev_pad (Hint: use X[pad:-pad, pad:-pad, :])</span></div><div class="line">        dA_prev[i, :, :, :] = dA_prev_pad[i, pad:-pad, pad:-pad, :]</div><div class="line">    <span class="comment">##END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="comment"># Making sure your output shape is correct</span></div><div class="line">    <span class="keyword">assert</span>(dA_prev.shape == (m, n_H_prev, n_W_prev, n_C_prev))</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dA_prev, dW, db</div></pre></td></tr></table></figure>
<h5 id="5-2-Pooling-layer-backward-pass"><a href="#5-2-Pooling-layer-backward-pass" class="headerlink" title="5.2 Pooling layer - backward pass"></a>5.2 Pooling layer - backward pass</h5><p>Next, let’s implement the backward pass for the pooling layer, starting with the MAX-POOL layer. Even though a pooling layer has no parameters for backprop to update, you still need to backpropagation the gradient through the pooling layer in order to compute gradients for layers that came before the pooling layer. </p>
<h6 id="5-2-1-Max-pooling-backward-pass"><a href="#5-2-1-Max-pooling-backward-pass" class="headerlink" title="5.2.1 Max pooling - backward pass"></a>5.2.1 Max pooling - backward pass</h6><p>Before jumping into the backpropagation of the pooling layer, you are going to build a helper function called <code>create_mask_from_window()</code> which does the following: </p>
<script type="math/tex; mode=display">X = \begin{bmatrix}
1 && 3 \\
4 && 2
\end{bmatrix} \quad \rightarrow  \quad M =\begin{bmatrix}
0 && 0 \\
1 && 0
\end{bmatrix}</script><p>As you can see, this function creates a “mask” matrix which keeps track of where the maximum of the matrix is. True (1) indicates the position of the maximum in X, the other entries are False (0). You’ll see later that the backward pass for average pooling will be similar to this but using a different mask.  </p>
<p><strong>Exercise</strong>: Implement <code>create_mask_from_window()</code>. This function will be helpful for pooling backward.<br>Hints:</p>
<ul>
<li><a href="">np.max()</a> may be helpful. It computes the maximum of an array.</li>
<li><p>If you have a matrix X and a scalar x: <code>A = (X == x)</code> will return a matrix A of the same size as X such that:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">A[i,j] = True if X[i,j] = x</div><div class="line">A[i,j] = False if X[i,j] != x</div></pre></td></tr></table></figure>
</li>
<li><p>Here, you don’t need to consider cases where there are several maxima in a matrix.</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_mask_from_window</span><span class="params">(x)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Creates a mask from an input matrix x, to identify the max entry of x.</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    x -- Array of shape (f, f)</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    mask -- Array of the same shape as window, contains a True at the position corresponding to the max entry of x.</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    <span class="comment">##START CODE HERE ##(≈1 line)</span></div><div class="line">    mask = (x == np.max(x))</div><div class="line">    <span class="comment">##END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> mask</div></pre></td></tr></table></figure>
<p>Why do we keep track of the position of the max? It’s because this is the input value that ultimately influenced the output, and therefore the cost. Backprop is computing gradients with respect to the cost, so anything that influences the ultimate cost should have a non-zero gradient. So, backprop will “propagate” the gradient back to this particular input value that had influenced the cost. </p>
<h6 id="5-2-2-Average-pooling-backward-pass"><a href="#5-2-2-Average-pooling-backward-pass" class="headerlink" title="5.2.2 - Average pooling - backward pass"></a>5.2.2 - Average pooling - backward pass</h6><p>In max pooling, for each input window, all the “influence” on the output came from a single input value—the max. In average pooling, every element of the input window has equal influence on the output. So to implement backprop, you will now implement a helper function that reflects this.</p>
<p>For example if we did average pooling in the forward pass using a 2x2 filter, then the mask you’ll use for the backward pass will look like: </p>
<script type="math/tex; mode=display">dZ = 1 \quad \rightarrow  \quad dZ =\begin{bmatrix}
1/4 && 1/4 \\
1/4 && 1/4
\end{bmatrix}</script><p>This implies that each position in the $dZ$ matrix contributes equally to output because in the forward pass, we took an average. </p>
<p><strong>Exercise</strong>: Implement the function below to equally distribute a value dz through a matrix of dimension shape. <a href="https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ones.html" target="_blank" rel="external">Hint</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">distribute_value</span><span class="params">(dz, shape)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Distributes the input value in the matrix of dimension shape</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    dz -- input scalar</span></div><div class="line"><span class="string">    shape -- the shape (n_H, n_W) of the output matrix for which we want to distribute the value of dz</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    a -- Array of size (n_H, n_W) for which we distributed the value of dz</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    <span class="comment">##START CODE HERE ###</span></div><div class="line">    <span class="comment"># Retrieve dimensions from shape (≈1 line)</span></div><div class="line">    (n_H, n_W) = shape</div><div class="line">    </div><div class="line">    <span class="comment"># Compute the value to distribute on the matrix (≈1 line)</span></div><div class="line">    average = n_H * n_W</div><div class="line">    </div><div class="line">    <span class="comment"># Create a matrix where every entry is the "average" value (≈1 line)</span></div><div class="line">    a = np.ones(shape) * dz / average</div><div class="line">    <span class="comment">##END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> a</div></pre></td></tr></table></figure>
<h6 id="5-2-3-Putting-it-together-Pooling-backward"><a href="#5-2-3-Putting-it-together-Pooling-backward" class="headerlink" title="5.2.3 Putting it together: Pooling backward"></a>5.2.3 Putting it together: Pooling backward</h6><p>You now have everything you need to compute backward propagation on a pooling layer.</p>
<p><strong>Exercise</strong>: Implement the <code>pool_backward</code> function in both modes (<code>&quot;max&quot;</code> and <code>&quot;average&quot;</code>). You will once again use 4 for-loops (iterating over training examples, height, width, and channels). You should use an <code>if/elif</code> statement to see if the mode is equal to <code>&#39;max&#39;</code> or <code>&#39;average&#39;</code>. If it is equal to ‘average’ you should use the <code>distribute_value()</code> function you implemented above to create a matrix of the same shape as <code>a_slice</code>. Otherwise, the mode is equal to ‘<code>max</code>‘, and you will create a mask with <code>create_mask_from_window()</code> and multiply it by the corresponding value of dZ.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">pool_backward</span><span class="params">(dA, cache, mode = <span class="string">"max"</span>)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Implements the backward pass of the pooling layer</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    dA -- gradient of cost with respect to the output of the pooling layer, same shape as A</span></div><div class="line"><span class="string">    cache -- cache output from the forward pass of the pooling layer, contains the layer's input and hparameters </span></div><div class="line"><span class="string">    mode -- the pooling mode you would like to use, defined as a string ("max" or "average")</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    dA_prev -- gradient of cost with respect to the input of the pooling layer, same shape as A_prev</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    <span class="comment">##START CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="comment"># Retrieve information from cache (≈1 line)</span></div><div class="line">    (A_prev, hparameters) = cache</div><div class="line">    </div><div class="line">    <span class="comment"># Retrieve hyperparameters from "hparameters" (≈2 lines)</span></div><div class="line">    stride = hparameters[<span class="string">"stride"</span>]</div><div class="line">    f = hparameters[<span class="string">"f"</span>]</div><div class="line">    </div><div class="line">    <span class="comment"># Retrieve dimensions from A_prev's shape and dA's shape (≈2 lines)</span></div><div class="line">    m, n_H_prev, n_W_prev, n_C_prev = A_prev.shape</div><div class="line">    m, n_H, n_W, n_C = dA.shape</div><div class="line">    </div><div class="line">    <span class="comment"># Initialize dA_prev with zeros (≈1 line)</span></div><div class="line">    dA_prev = np.zeros(A_prev.shape)</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):                       <span class="comment"># loop over the training examples</span></div><div class="line">        <span class="comment">#select training example from A_prev (≈1 line)</span></div><div class="line">        a_prev = A_prev[i,:]</div><div class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> range(n_H):                 <span class="comment">#  loop on the vertical axis</span></div><div class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> range(n_W):             <span class="comment">#  loop on the horizontal axis</span></div><div class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> range(n_C):         <span class="comment">#  loop over the channels (depth)</span></div><div class="line">                    </div><div class="line">                    <span class="comment"># Find the corners of the current "slice" (≈4 lines)</span></div><div class="line">                    vert_start = h * stride</div><div class="line">                    vert_end = vert_start + f</div><div class="line">                    horiz_start = w * stride</div><div class="line">                    horiz_end = horiz_start + f </div><div class="line">                    </div><div class="line">                    <span class="comment"># Compute the backward propagation in both modes.</span></div><div class="line">                    <span class="keyword">if</span> mode == <span class="string">"max"</span>:</div><div class="line">                        <span class="comment"># Use the corners and "c" to define the current slice from a_prev (≈1 line)</span></div><div class="line">                        a_prev_slice = a_prev[vert_start:vert_end,horiz_start:horiz_end,c]</div><div class="line">                        <span class="comment"># Create the mask from a_prev_slice (≈1 line)</span></div><div class="line">                        mask = create_mask_from_window(a_prev_slice)</div><div class="line">                        <span class="comment"># Set dA_prev to be dA_prev + (the mask multiplied by the correct entry of dA) (≈1 line)</span></div><div class="line">                        dA_prev[i, vert_start: vert_end, horiz_start: horiz_end, c] += mask * dA[i,h,w,c]</div><div class="line">                        </div><div class="line">                    <span class="keyword">elif</span> mode == <span class="string">"average"</span>:</div><div class="line">                        </div><div class="line">                        <span class="comment"># Get the value a from dA (≈1 line)</span></div><div class="line">                        da = dA[i, h, w , c]</div><div class="line">                        <span class="comment"># Define the shape of the filter as fxf (≈1 line)</span></div><div class="line">                        shape = (f,f)</div><div class="line">                        <span class="comment"># Distribute it to get the correct slice of dA_prev. i.e. Add the distributed value of da. (≈1 line)</span></div><div class="line">                        dA_prev[i, vert_start: vert_end, horiz_start: horiz_end, c] += distribute_value(da, shape)</div><div class="line">                        </div><div class="line">    <span class="comment">##END CODE ###</span></div><div class="line">    </div><div class="line">    <span class="comment"># Making sure your output shape is correct</span></div><div class="line">    <span class="keyword">assert</span>(dA_prev.shape == A_prev.shape)</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> dA_prev</div></pre></td></tr></table></figure>
<h5 id="Congratulations"><a href="#Congratulations" class="headerlink" title="Congratulations !"></a>Congratulations !</h5><p>Congratulation on completing this assignment. You now understand how convolutional neural networks work. You have implemented all the building blocks of a neural network. In the next assignment you will implement a ConvNet using TensorFlow.</p>
<h3 id="Convolutional-Neural-Networks-Application"><a href="#Convolutional-Neural-Networks-Application" class="headerlink" title="Convolutional Neural Networks: Application"></a>Convolutional Neural Networks: Application</h3><p>Welcome to Course 4’s second assignment! In this notebook, you will:</p>
<ul>
<li>Implement helper functions that you will use when implementing a TensorFlow model</li>
<li>Implement a fully functioning ConvNet using TensorFlow </li>
</ul>
<p><strong>After this assignment you will be able to:</strong></p>
<ul>
<li>Build and train a ConvNet in TensorFlow for a classification problem </li>
</ul>
<p>We assume here that you are already familiar with TensorFlow. If you are not, please refer the <em>TensorFlow Tutorial</em> of the third week of Course 2 (“<em>Improving deep neural networks</em>“).</p>
<h4 id="1-TensorFlow-model"><a href="#1-TensorFlow-model" class="headerlink" title="1 - TensorFlow model"></a>1 - TensorFlow model</h4><p>In the previous assignment, you built helper functions using numpy to understand the mechanics behind convolutional neural networks. Most practical applications of deep learning today are built using programming frameworks, which have many built-in functions you can simply call. </p>
<p>As usual, we will start by loading in the packages. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> math</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> h5py</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> scipy</div><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> ndimage</div><div class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</div><div class="line"><span class="keyword">from</span> tensorflow.python.framework <span class="keyword">import</span> ops</div><div class="line"><span class="keyword">from</span> cnn_utils <span class="keyword">import</span> *</div><div class="line"></div><div class="line">get_ipython().magic(<span class="string">'matplotlib inline'</span>)</div><div class="line">np.random.seed(<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>Run the next cell to load the “SIGNS” dataset you are going to use.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># Loading the data (signs)</span></div><div class="line">X_train_orig, Y_train_orig, X_test_orig, Y_test_orig, classes = load_dataset()</div></pre></td></tr></table></figure>
<p>As a reminder, the SIGNS dataset is a collection of 6 signs representing numbers from 0 to 5.</p>
<img src="/2018/10/15/coursera-deeplearning-ai-c4-week1/SIGNS.png" alt="SIGNS.png" title="">
<p>The next cell will show you an example of a labelled image in the dataset. Feel free to change the value of <code>index</code> below and re-run to see different examples. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># Example of a picture</span></div><div class="line">index = <span class="number">6</span></div><div class="line">plt.imshow(X_train_orig[index])</div><div class="line"><span class="keyword">print</span> (<span class="string">"y = "</span> + str(np.squeeze(Y_train_orig[:, index])))</div></pre></td></tr></table></figure>
<p>In Course 2, you had built a fully-connected network for this dataset. But since this is an image dataset, it is more natural to apply a ConvNet to it.</p>
<p>To get started, let’s examine the shapes of your data. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">X_train = X_train_orig/<span class="number">255.</span></div><div class="line">X_test = X_test_orig/<span class="number">255.</span></div><div class="line">Y_train = convert_to_one_hot(Y_train_orig, <span class="number">6</span>).T</div><div class="line">Y_test = convert_to_one_hot(Y_test_orig, <span class="number">6</span>).T</div><div class="line"><span class="keyword">print</span> (<span class="string">"number of training examples = "</span> + str(X_train.shape[<span class="number">0</span>]))</div><div class="line"><span class="keyword">print</span> (<span class="string">"number of test examples = "</span> + str(X_test.shape[<span class="number">0</span>]))</div><div class="line"><span class="keyword">print</span> (<span class="string">"X_train shape: "</span> + str(X_train.shape))</div><div class="line"><span class="keyword">print</span> (<span class="string">"Y_train shape: "</span> + str(Y_train.shape))</div><div class="line"><span class="keyword">print</span> (<span class="string">"X_test shape: "</span> + str(X_test.shape))</div><div class="line"><span class="keyword">print</span> (<span class="string">"Y_test shape: "</span> + str(Y_test.shape))</div><div class="line">conv_layers = &#123;&#125;</div></pre></td></tr></table></figure>
<h5 id="1-1-Create-placeholders"><a href="#1-1-Create-placeholders" class="headerlink" title="1.1 - Create placeholders"></a>1.1 - Create placeholders</h5><p>TensorFlow requires that you create placeholders for the input data that will be fed into the model when running the session.</p>
<p><strong>Exercise</strong>: Implement the function below to create placeholders for the input image X and the output Y. You should not define the number of training examples for the moment. To do so, you could use “None” as the batch size, it will give you the flexibility to choose it later. Hence X should be of dimension <strong>[None, n_H0, n_W0, n_C0]</strong> and Y should be of dimension <strong>[None, n_y]</strong>.  <a href="https://www.tensorflow.org/api_docs/python/tf/placeholder" target="_blank" rel="external">Hint</a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#GRADED FUNCTION: create_placeholders</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_placeholders</span><span class="params">(n_H0, n_W0, n_C0, n_y)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Creates the placeholders for the tensorflow session.</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    n_H0 -- scalar, height of an input image</span></div><div class="line"><span class="string">    n_W0 -- scalar, width of an input image</span></div><div class="line"><span class="string">    n_C0 -- scalar, number of channels of the input</span></div><div class="line"><span class="string">    n_y -- scalar, number of classes</span></div><div class="line"><span class="string">        </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    X -- placeholder for the data input, of shape [None, n_H0, n_W0, n_C0] and dtype "float"</span></div><div class="line"><span class="string">    Y -- placeholder for the input labels, of shape [None, n_y] and dtype "float"</span></div><div class="line"><span class="string">    """</span></div><div class="line"></div><div class="line">    <span class="comment">### START CODE HERE ### (≈2 lines)</span></div><div class="line">    X = tf.placeholder(shape = [<span class="keyword">None</span>,n_H0, n_W0, n_C0], dtype = <span class="string">"float32"</span>, name = <span class="string">"X"</span>)</div><div class="line">    Y = tf.placeholder(shape = [<span class="keyword">None</span>, n_y] , dtype = <span class="string">"float32"</span>, name = <span class="string">"Y"</span>)</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> X, Y</div></pre></td></tr></table></figure>
<h5 id="1-2-Initialize-parameters"><a href="#1-2-Initialize-parameters" class="headerlink" title="1.2 - Initialize parameters"></a>1.2 - Initialize parameters</h5><p>You will initialize weights/filters $W1$ and $W2$ using <code>tf.contrib.layers.xavier_initializer(seed = 0)</code>. You don’t need to worry about bias variables as you will soon see that TensorFlow functions take care of the bias. Note also that you will only initialize the weights/filters for the conv2d functions. TensorFlow initializes the layers for the fully connected part automatically. We will talk more about that later in this assignment.</p>
<p><strong>Exercise:</strong> Implement initialize_parameters(). The dimensions for each group of filters are provided below. Reminder - to initialize a parameter $W$ of shape [1,2,3,4] in Tensorflow, use:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">W = tf.get_variable(<span class="string">"W"</span>, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], initializer = ...)</div></pre></td></tr></table></figure>
<p><a href="https://www.tensorflow.org/api_docs/python/tf/get_variable" target="_blank" rel="external">More Info</a>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#GRADED FUNCTION: initialize_parameters</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize_parameters</span><span class="params">()</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Initializes weight parameters to build a neural network with tensorflow. The shapes are:</span></div><div class="line"><span class="string">                        W1 : [4, 4, 3, 8]</span></div><div class="line"><span class="string">                        W2 : [2, 2, 8, 16]</span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    parameters -- a dictionary of tensors containing W1, W2</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    tf.set_random_seed(<span class="number">1</span>) <span class="comment"># so that your "random" numbers match ours</span></div><div class="line">        </div><div class="line">    <span class="comment">### START CODE HERE ### (approx. 2 lines of code)</span></div><div class="line">    W1 = tf.get_variable(<span class="string">"W1"</span>, [<span class="number">4</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>], initializer = tf.contrib.layers.xavier_initializer(seed = <span class="number">0</span>))</div><div class="line">    W2 = tf.get_variable(<span class="string">"W2"</span>, [<span class="number">2</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">16</span>], initializer = tf.contrib.layers.xavier_initializer(seed = <span class="number">0</span>))</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line"></div><div class="line">    parameters = &#123;<span class="string">"W1"</span>: W1,</div><div class="line">                  <span class="string">"W2"</span>: W2&#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> parameters</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">tf.reset_default_graph()</div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess_test:</div><div class="line">    parameters = initialize_parameters()</div><div class="line">    init = tf.global_variables_initializer()</div><div class="line">    sess_test.run(init)</div><div class="line">    print(<span class="string">"W1 = "</span> + str(parameters[<span class="string">"W1"</span>].eval()[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]))</div><div class="line">    print(<span class="string">"W2 = "</span> + str(parameters[<span class="string">"W2"</span>].eval()[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]))</div></pre></td></tr></table></figure>
<h4 id="2-Forward-propagation"><a href="#2-Forward-propagation" class="headerlink" title="2 - Forward propagation"></a>2 - Forward propagation</h4><p>In TensorFlow, there are built-in functions that carry out the convolution steps for you.</p>
<ul>
<li><p><strong>tf.nn.conv2d(X,W1, strides = [1,s,s,1], padding = ‘SAME’):</strong> given an input $X$ and a group of filters $W1$, this function convolves $W1$’s filters on X. The third input ([1,f,f,1]) represents the strides for each dimension of the input (m, n_H_prev, n_W_prev, n_C_prev). You can read the full documentation <a href="https://www.tensorflow.org/api_docs/python/tf/nn/conv2d" target="_blank" rel="external">here</a></p>
</li>
<li><p><strong>tf.nn.max_pool(A, ksize = [1,f,f,1], strides = [1,s,s,1], padding = ‘SAME’):</strong> given an input A, this function uses a window of size (f, f) and strides of size (s, s) to carry out max pooling over each window. You can read the full documentation <a href="https://www.tensorflow.org/api_docs/python/tf/nn/max_pool" target="_blank" rel="external">here</a></p>
</li>
<li><p><strong>tf.nn.relu(Z1):</strong> computes the elementwise ReLU of Z1 (which can be any shape). You can read the full documentation <a href="https://www.tensorflow.org/api_docs/python/tf/nn/relu" target="_blank" rel="external">here.</a></p>
</li>
<li><p><strong>tf.contrib.layers.flatten(P)</strong>: given an input P, this function flattens each example into a 1D vector it while maintaining the batch-size. It returns a flattened tensor with shape [batch_size, k]. You can read the full documentation <a href="https://www.tensorflow.org/api_docs/python/tf/contrib/layers/flatten" target="_blank" rel="external">here.</a></p>
</li>
<li><p><strong>tf.contrib.layers.fully_connected(F, num_outputs):</strong> given a the flattened input F, it returns the output computed using a fully connected layer. You can read the full documentation <a href="https://www.tensorflow.org/api_docs/python/tf/contrib/layers/fully_connected" target="_blank" rel="external">here.</a></p>
</li>
</ul>
<p>In the last function above (<code>tf.contrib.layers.fully_connected</code>), the fully connected layer automatically initializes weights in the graph and keeps on training them as you train the model. Hence, you did not need to initialize those weights when initializing the parameters. </p>
<p><strong>Exercise</strong>: </p>
<p>Implement the <code>forward_propagation</code> function below to build the following model: <code>CONV2D -&gt; RELU -&gt; MAXPOOL -&gt; CONV2D -&gt; RELU -&gt; MAXPOOL -&gt; FLATTEN -&gt; FULLYCONNECTED</code>. You should use the functions above. </p>
<p>In detail, we will use the following parameters for all the steps:</p>
<pre><code> - Conv2D: stride 1, padding is &quot;SAME&quot;
 - ReLU
 - Max pool: Use an 8 by 8 filter size and an 8 by 8 stride, padding is &quot;SAME&quot;
 - Conv2D: stride 1, padding is &quot;SAME&quot;
 - ReLU
 - Max pool: Use a 4 by 4 filter size and a 4 by 4 stride, padding is &quot;SAME&quot;
 - Flatten the previous output.
 - FULLYCONNECTED (FC) layer: Apply a fully connected layer without an non-linear activation function. Do not call the softmax here. This will result in 6 neurons in the output layer, which then get passed later to a softmax. In TensorFlow, the softmax and cost function are lumped together into a single function, which you&#39;ll call in a different function when computing the cost. 
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># GRADED FUNCTION: forward_propagation</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_propagation</span><span class="params">(X, parameters)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Implements the forward propagation for the model:</span></div><div class="line"><span class="string">    CONV2D -&gt; RELU -&gt; MAXPOOL -&gt; CONV2D -&gt; RELU -&gt; MAXPOOL -&gt; FLATTEN -&gt; FULLYCONNECTED</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    X -- input dataset placeholder, of shape (input size, number of examples)</span></div><div class="line"><span class="string">    parameters -- python dictionary containing your parameters "W1", "W2"</span></div><div class="line"><span class="string">                  the shapes are given in initialize_parameters</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    Z3 -- the output of the last LINEAR unit</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    <span class="comment"># Retrieve the parameters from the dictionary "parameters" </span></div><div class="line">    W1 = parameters[<span class="string">'W1'</span>]</div><div class="line">    W2 = parameters[<span class="string">'W2'</span>]</div><div class="line">    </div><div class="line">    <span class="comment">### START CODE HERE ###</span></div><div class="line">    <span class="comment"># CONV2D: stride of 1, padding 'SAME'</span></div><div class="line">    Z1 = tf.nn.conv2d(X,W1, strides = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], padding = <span class="string">'SAME'</span>)</div><div class="line">    <span class="comment"># RELU</span></div><div class="line">    A1 = tf.nn.relu(Z1)</div><div class="line">    <span class="comment"># MAXPOOL: window 8x8, sride 8, padding 'SAME'</span></div><div class="line">    P1 = tf.nn.max_pool(A1, ksize = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">1</span>], strides = [<span class="number">1</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">1</span>], padding = <span class="string">'SAME'</span>)</div><div class="line">    <span class="comment"># CONV2D: filters W2, stride 1, padding 'SAME'</span></div><div class="line">    Z2 = tf.nn.conv2d(P1,W2, strides = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], padding = <span class="string">'SAME'</span>)</div><div class="line">    <span class="comment"># RELU</span></div><div class="line">    A2 = tf.nn.relu(Z2)</div><div class="line">    <span class="comment"># MAXPOOL: window 4x4, stride 4, padding 'SAME'</span></div><div class="line">    P2 = tf.nn.max_pool(A2, ksize = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>], strides = [<span class="number">1</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">1</span>],padding = <span class="string">'SAME'</span>)</div><div class="line">    <span class="comment"># FLATTEN</span></div><div class="line">    P2 = tf.contrib.layers.flatten(P2)</div><div class="line">    <span class="comment"># FULLY-CONNECTED without non-linear activation function (not not call softmax).</span></div><div class="line">    <span class="comment"># 6 neurons in output layer. Hint: one of the arguments should be "activation_fn=None" </span></div><div class="line">    Z3 = tf.contrib.layers.fully_connected(P2, <span class="number">6</span>, activation_fn=<span class="keyword">None</span>)</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> Z3</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">tf.reset_default_graph()</div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    np.random.seed(<span class="number">1</span>)</div><div class="line">    X, Y = create_placeholders(<span class="number">64</span>, <span class="number">64</span>, <span class="number">3</span>, <span class="number">6</span>)</div><div class="line">    parameters = initialize_parameters()</div><div class="line">    Z3 = forward_propagation(X, parameters)</div><div class="line">    init = tf.global_variables_initializer()</div><div class="line">    sess.run(init)</div><div class="line">    a = sess.run(Z3, &#123;X: np.random.randn(<span class="number">2</span>,<span class="number">64</span>,<span class="number">64</span>,<span class="number">3</span>), Y: np.random.randn(<span class="number">2</span>,<span class="number">6</span>)&#125;)</div><div class="line">    print(<span class="string">"Z3 = "</span> + str(a))</div></pre></td></tr></table></figure>
<h4 id="3-Compute-cost"><a href="#3-Compute-cost" class="headerlink" title="3 - Compute cost"></a>3 - Compute cost</h4><p>Implement the compute cost function below. You might find these two functions helpful: </p>
<ul>
<li><strong>tf.nn.softmax_cross_entropy_with_logits(logits = Z3, labels = Y):</strong> computes the softmax entropy loss. This function both computes the softmax activation function as well as the resulting loss. You can check the full documentation  <a href="https://www.tensorflow.org/api_docs/python/tf/nn/softmax_cross_entropy_with_logits" target="_blank" rel="external">here.</a></li>
<li><strong>tf.reduce_mean:</strong> computes the mean of elements across dimensions of a tensor. Use this to sum the losses over all the examples to get the overall cost. You can check the full documentation <a href="https://www.tensorflow.org/api_docs/python/tf/reduce_mean" target="_blank" rel="external">here.</a></li>
</ul>
<p><strong>Exercise</strong>: Compute the cost below using the function above.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#GRADED FUNCTION: compute_cost </span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_cost</span><span class="params">(Z3, Y)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Computes the cost</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    Z3 -- output of forward propagation (output of the last LINEAR unit), of shape (6, number of examples)</span></div><div class="line"><span class="string">    Y -- "true" labels vector placeholder, same shape as Z3</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    cost - Tensor of the cost function</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    <span class="comment">### START CODE HERE ### (1 line of code)</span></div><div class="line">    cost = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits = Z3, labels = Y))</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="keyword">return</span> cost</div></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">tf.reset_default_graph()</div><div class="line"></div><div class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">    np.random.seed(<span class="number">1</span>)</div><div class="line">    X, Y = create_placeholders(<span class="number">64</span>, <span class="number">64</span>, <span class="number">3</span>, <span class="number">6</span>)</div><div class="line">    parameters = initialize_parameters()</div><div class="line">    Z3 = forward_propagation(X, parameters)</div><div class="line">    cost = compute_cost(Z3, Y)</div><div class="line">    init = tf.global_variables_initializer()</div><div class="line">    sess.run(init)</div><div class="line">    a = sess.run(cost, &#123;X: np.random.randn(<span class="number">4</span>,<span class="number">64</span>,<span class="number">64</span>,<span class="number">3</span>), Y: np.random.randn(<span class="number">4</span>,<span class="number">6</span>)&#125;)</div><div class="line">    print(<span class="string">"cost = "</span> + str(a))</div></pre></td></tr></table></figure>
<h4 id="4-Model"><a href="#4-Model" class="headerlink" title="4 Model"></a>4 Model</h4><p>Finally you will merge the helper functions you implemented above to build a model. You will train it on the SIGNS dataset. </p>
<p>You have implemented <code>random_mini_batches()</code> in the Optimization programming assignment of course 2. Remember that this function returns a list of mini-batches. </p>
<p><strong>Exercise</strong>: Complete the function below. </p>
<p>The model below should:</p>
<ul>
<li>create placeholders</li>
<li>initialize parameters</li>
<li>forward propagate</li>
<li>compute the cost</li>
<li>create an optimizer</li>
</ul>
<p>Finally you will create a session and run a for loop  for num_epochs, get the mini-batches, and then for each mini-batch you will optimize the function. <a href="https://www.tensorflow.org/api_docs/python/tf/global_variables_initializer" target="_blank" rel="external">Hint for initializing the variables</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#GRADED FUNCTION: model</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">model</span><span class="params">(X_train, Y_train, X_test, Y_test, learning_rate = <span class="number">0.009</span>,</span></span></div><div class="line"><span class="function"><span class="params">          num_epochs = <span class="number">100</span>, minibatch_size = <span class="number">64</span>, print_cost = True)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    Implements a three-layer ConvNet in Tensorflow:</span></div><div class="line"><span class="string">    CONV2D -&gt; RELU -&gt; MAXPOOL -&gt; CONV2D -&gt; RELU -&gt; MAXPOOL -&gt; FLATTEN -&gt; FULLYCONNECTED</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Arguments:</span></div><div class="line"><span class="string">    X_train -- training set, of shape (None, 64, 64, 3)</span></div><div class="line"><span class="string">    Y_train -- test set, of shape (None, n_y = 6)</span></div><div class="line"><span class="string">    X_test -- training set, of shape (None, 64, 64, 3)</span></div><div class="line"><span class="string">    Y_test -- test set, of shape (None, n_y = 6)</span></div><div class="line"><span class="string">    learning_rate -- learning rate of the optimization</span></div><div class="line"><span class="string">    num_epochs -- number of epochs of the optimization loop</span></div><div class="line"><span class="string">    minibatch_size -- size of a minibatch</span></div><div class="line"><span class="string">    print_cost -- True to print the cost every 100 epochs</span></div><div class="line"><span class="string">    </span></div><div class="line"><span class="string">    Returns:</span></div><div class="line"><span class="string">    train_accuracy -- real number, accuracy on the train set (X_train)</span></div><div class="line"><span class="string">    test_accuracy -- real number, testing accuracy on the test set (X_test)</span></div><div class="line"><span class="string">    parameters -- parameters learnt by the model. They can then be used to predict.</span></div><div class="line"><span class="string">    """</span></div><div class="line">    </div><div class="line">    ops.reset_default_graph()                         <span class="comment"># to be able to rerun the model without overwriting tf variables</span></div><div class="line">    tf.set_random_seed(<span class="number">1</span>)                             <span class="comment"># to keep results consistent (tensorflow seed)</span></div><div class="line">    seed = <span class="number">3</span>                                          <span class="comment"># to keep results consistent (numpy seed)</span></div><div class="line">    (m, n_H0, n_W0, n_C0) = X_train.shape             </div><div class="line">    n_y = Y_train.shape[<span class="number">1</span>]                            </div><div class="line">    costs = []                                        <span class="comment"># To keep track of the cost</span></div><div class="line">    </div><div class="line">    <span class="comment"># Create Placeholders of the correct shape</span></div><div class="line">    <span class="comment">### START CODE HERE ### (1 line)</span></div><div class="line">    X, Y = create_placeholders(n_H0, n_W0, n_C0, n_y)</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line"></div><div class="line">    <span class="comment"># Initialize parameters</span></div><div class="line">    <span class="comment">### START CODE HERE ### (1 line)</span></div><div class="line">    parameters = initialize_parameters()</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="comment"># Forward propagation: Build the forward propagation in the tensorflow graph</span></div><div class="line">    <span class="comment">### START CODE HERE ### (1 line)</span></div><div class="line">    Z3 = forward_propagation(X, parameters)</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="comment"># Cost function: Add cost function to tensorflow graph</span></div><div class="line">    <span class="comment">### START CODE HERE ### (1 line)</span></div><div class="line">    cost = compute_cost(Z3, Y)</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="comment"># Backpropagation: Define the tensorflow optimizer. Use an AdamOptimizer that minimizes the cost.</span></div><div class="line">    <span class="comment">### START CODE HERE ### (1 line)</span></div><div class="line">    optimizer = tf.train.AdamOptimizer(learning_rate = learning_rate).minimize(cost)</div><div class="line">    <span class="comment">### END CODE HERE ###</span></div><div class="line">    </div><div class="line">    <span class="comment"># Initialize all the variables globally</span></div><div class="line">    init = tf.global_variables_initializer()</div><div class="line">     </div><div class="line">    <span class="comment"># Start the session to compute the tensorflow graph</span></div><div class="line">    <span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</div><div class="line">        </div><div class="line">        <span class="comment"># Run the initialization</span></div><div class="line">        sess.run(init)</div><div class="line">        </div><div class="line">        <span class="comment"># Do the training loop</span></div><div class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> range(num_epochs):</div><div class="line"></div><div class="line">            minibatch_cost = <span class="number">0.</span></div><div class="line">            num_minibatches = int(m / minibatch_size) <span class="comment"># number of minibatches of size minibatch_size in the train set</span></div><div class="line">            seed = seed + <span class="number">1</span></div><div class="line">            minibatches = random_mini_batches(X_train, Y_train, minibatch_size, seed)</div><div class="line"></div><div class="line">            <span class="keyword">for</span> minibatch <span class="keyword">in</span> minibatches:</div><div class="line"></div><div class="line">                <span class="comment"># Select a minibatch</span></div><div class="line">                (minibatch_X, minibatch_Y) = minibatch</div><div class="line">                <span class="comment"># IMPORTANT: The line that runs the graph on a minibatch.</span></div><div class="line">                <span class="comment"># Run the session to execute the optimizer and the cost, the feedict should contain a minibatch for (X,Y).</span></div><div class="line">                <span class="comment">### START CODE HERE ### (1 line)</span></div><div class="line">                _ , temp_cost = sess.run([optimizer,cost], feed_dict = &#123;X:minibatch_X, Y:minibatch_Y&#125;)</div><div class="line">                <span class="comment">### END CODE HERE ###</span></div><div class="line">                </div><div class="line">                minibatch_cost += temp_cost / num_minibatches</div><div class="line">                </div><div class="line"></div><div class="line">            <span class="comment"># Print the cost every epoch</span></div><div class="line">            <span class="keyword">if</span> print_cost == <span class="keyword">True</span> <span class="keyword">and</span> epoch % <span class="number">5</span> == <span class="number">0</span>:</div><div class="line">                <span class="keyword">print</span> (<span class="string">"Cost after epoch %i: %f"</span> % (epoch, minibatch_cost))</div><div class="line">            <span class="keyword">if</span> print_cost == <span class="keyword">True</span> <span class="keyword">and</span> epoch % <span class="number">1</span> == <span class="number">0</span>:</div><div class="line">                costs.append(minibatch_cost)</div><div class="line">        </div><div class="line">        </div><div class="line">        <span class="comment"># plot the cost</span></div><div class="line">        plt.plot(np.squeeze(costs))</div><div class="line">        plt.ylabel(<span class="string">'cost'</span>)</div><div class="line">        plt.xlabel(<span class="string">'iterations (per tens)'</span>)</div><div class="line">        plt.title(<span class="string">"Learning rate ="</span> + str(learning_rate))</div><div class="line">        plt.show()</div><div class="line"></div><div class="line">        <span class="comment"># Calculate the correct predictions</span></div><div class="line">        predict_op = tf.argmax(Z3, <span class="number">1</span>)</div><div class="line">        correct_prediction = tf.equal(predict_op, tf.argmax(Y, <span class="number">1</span>))</div><div class="line">        </div><div class="line">        <span class="comment"># Calculate accuracy on the test set</span></div><div class="line">        accuracy = tf.reduce_mean(tf.cast(correct_prediction, <span class="string">"float"</span>))</div><div class="line">        print(accuracy)</div><div class="line">        train_accuracy = accuracy.eval(&#123;X: X_train, Y: Y_train&#125;)</div><div class="line">        test_accuracy = accuracy.eval(&#123;X: X_test, Y: Y_test&#125;)</div><div class="line">        print(<span class="string">"Train Accuracy:"</span>, train_accuracy)</div><div class="line">        print(<span class="string">"Test Accuracy:"</span>, test_accuracy)</div><div class="line">                </div><div class="line">        <span class="keyword">return</span> train_accuracy, test_accuracy, parameters</div></pre></td></tr></table></figure>
<p>Run the following cell to train your model for 100 epochs. Check if your cost after epoch 0 and 5 matches our output. If not, stop the cell and go back to your code!</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_, _, parameters = model(X_train, Y_train, X_test, Y_test)</div></pre></td></tr></table></figure>
<p><strong>Expected output</strong>: although it may not match perfectly, your expected output should be close to ours and your cost value should decrease.</p>
<table> 
<tr>
    <td> 
    **Cost after epoch 0 =**
    </td>
    <td> 
      1.917929
    </td> 
</tr>
<tr>
    <td> 
    **Cost after epoch 5 =**
    </td>
    <td> 
      1.506757
    </td> 
</tr>
<tr>
    <td> 
    **Train Accuracy   =**
    </td>
    <td> 
      0.940741
    </td> 
</tr> 
<tr>
    <td> 
    **Test Accuracy   =**
    </td>
    <td> 
      0.783333
    </td> 
</tr> 
</table>

<p>Congratulations! You have finised the assignment and built a model that recognizes SIGN language with almost 80% accuracy on the test set. If you wish, feel free to play around with this dataset further. You can actually improve its accuracy by spending more time tuning the hyperparameters, or using regularization (as this model clearly has a high variance). </p>
<p>Once again, here’s a thumbs up for your work! </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fname = <span class="string">"images/thumbs_up.jpg"</span></div><div class="line">image = np.array(ndimage.imread(fname, flatten=<span class="keyword">False</span>))</div><div class="line">my_image = scipy.misc.imresize(image, size=(<span class="number">64</span>,<span class="number">64</span>))</div><div class="line">plt.imshow(my_image)</div></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/05/coursera-deeplearning-ai-c2-week3/" rel="next" title="coursera-deeplearning-ai-c2-week3">
                <i class="fa fa-chevron-left"></i> coursera-deeplearning-ai-c2-week3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/25/coursera-deeplearning-ai-c4-week2/" rel="prev" title="coursera-deeplearning-ai-c4-week2">
                coursera-deeplearning-ai-c4-week2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="hypercomments_widget"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/wukong.png"
               alt="张阿楠" />
          <p class="site-author-name" itemprop="name">张阿楠</p>
           
              <p class="site-description motion-element" itemprop="description">Keep codeing and thinking!</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">58</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">28</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/vernlium" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/ananzhang" target="_blank" title="ZhiHu">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                    
                      ZhiHu
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#课程笔记"><span class="nav-number">1.</span> <span class="nav-text">课程笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Convolutional-Neural-Networks"><span class="nav-number">1.1.</span> <span class="nav-text">Convolutional Neural Networks</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Computer-Vision"><span class="nav-number">1.1.1.</span> <span class="nav-text">Computer Vision</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Edge-Detection-Example"><span class="nav-number">1.1.2.</span> <span class="nav-text">Edge Detection Example</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#More-Edge-Detection"><span class="nav-number">1.1.3.</span> <span class="nav-text">More Edge Detection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Padding"><span class="nav-number">1.1.4.</span> <span class="nav-text">Padding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Strided-Convolutions"><span class="nav-number">1.1.5.</span> <span class="nav-text">Strided Convolutions</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Convolutions-Over-Volume"><span class="nav-number">1.1.6.</span> <span class="nav-text">Convolutions Over Volume</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#One-Layer-of-a-Convolutional-Network"><span class="nav-number">1.1.7.</span> <span class="nav-text">One Layer of a Convolutional Network</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Simple-Convolutional-Network-Example"><span class="nav-number">1.1.8.</span> <span class="nav-text">Simple Convolutional Network Example</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pooling-Layers"><span class="nav-number">1.1.9.</span> <span class="nav-text">Pooling Layers</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CNN-Example"><span class="nav-number">1.1.10.</span> <span class="nav-text">CNN Example</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Why-Convolutions"><span class="nav-number">1.1.11.</span> <span class="nav-text">Why Convolutions?</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编程练习"><span class="nav-number">2.</span> <span class="nav-text">编程练习</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Convolutional-Neural-Networks-Step-by-Step"><span class="nav-number">2.1.</span> <span class="nav-text">Convolutional Neural Networks: Step by Step</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Packages"><span class="nav-number">2.1.1.</span> <span class="nav-text">1 - Packages</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Outline-of-the-Assignment"><span class="nav-number">2.1.2.</span> <span class="nav-text">2 - Outline of the Assignment</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Convolutional-Neural-Networks"><span class="nav-number">2.1.3.</span> <span class="nav-text">3 - Convolutional Neural Networks</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-Zero-Padding"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">3.1 - Zero-Padding</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-Single-step-of-convolution"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">3.2 - Single step of convolution</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-Convolutional-Neural-Networks-Forward-pass"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">3.3 - Convolutional Neural Networks - Forward pass</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Pooling-layer"><span class="nav-number">2.1.4.</span> <span class="nav-text">4 - Pooling layer</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-Forward-Pooling"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">4.1 - Forward Pooling</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Backpropagation-in-convolutional-neural-networks-OPTIONAL-UNGRADED"><span class="nav-number">2.1.5.</span> <span class="nav-text">5 - Backpropagation in convolutional neural networks (OPTIONAL / UNGRADED)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-Convolutional-layer-backward-pass"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">5.1 - Convolutional layer backward pass</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#5-1-1-Computing-dA"><span class="nav-number">2.1.5.1.1.</span> <span class="nav-text">5.1.1 - Computing dA</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-2-Computing-dW"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">5.1.2 - Computing dW</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#5-1-3-Computing-db"><span class="nav-number">2.1.5.2.1.</span> <span class="nav-text">5.1.3 - Computing db</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-Pooling-layer-backward-pass"><span class="nav-number">2.1.5.3.</span> <span class="nav-text">5.2 Pooling layer - backward pass</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#5-2-1-Max-pooling-backward-pass"><span class="nav-number">2.1.5.3.1.</span> <span class="nav-text">5.2.1 Max pooling - backward pass</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-2-2-Average-pooling-backward-pass"><span class="nav-number">2.1.5.3.2.</span> <span class="nav-text">5.2.2 - Average pooling - backward pass</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-2-3-Putting-it-together-Pooling-backward"><span class="nav-number">2.1.5.3.3.</span> <span class="nav-text">5.2.3 Putting it together: Pooling backward</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Congratulations"><span class="nav-number">2.1.5.4.</span> <span class="nav-text">Congratulations !</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Convolutional-Neural-Networks-Application"><span class="nav-number">2.2.</span> <span class="nav-text">Convolutional Neural Networks: Application</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-TensorFlow-model"><span class="nav-number">2.2.1.</span> <span class="nav-text">1 - TensorFlow model</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-Create-placeholders"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">1.1 - Create placeholders</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-Initialize-parameters"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">1.2 - Initialize parameters</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Forward-propagation"><span class="nav-number">2.2.2.</span> <span class="nav-text">2 - Forward propagation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Compute-cost"><span class="nav-number">2.2.3.</span> <span class="nav-text">3 - Compute cost</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Model"><span class="nav-number">2.2.4.</span> <span class="nav-text">4 Model</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张阿楠</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	

		<script type="text/javascript">
		_hcwp = window._hcwp || [];

		_hcwp.push({widget:"Bloggerstream", widget_id: 95829, selector:".hc-comment-count", label: "{\%COUNT%\}" });

		
		_hcwp.push({widget:"Stream", widget_id: 95829, xid: "2018/10/15/coursera-deeplearning-ai-c4-week1/"});
		

		(function() {
		if("HC_LOAD_INIT" in window)return;
		HC_LOAD_INIT = true;
		var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || "en").substr(0, 2).toLowerCase();
		var hcc = document.createElement("script"); hcc.type = "text/javascript"; hcc.async = true;
		hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://w.hypercomments.com/widget/hc/95829/"+lang+"/widget.js";
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(hcc, s.nextSibling);
		})();
		</script>

	










  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
